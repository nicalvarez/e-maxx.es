<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Топологическая сортировка</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="/data/jquery.js"></script><script type="text/javascript" src="/data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php" >home</a></li><li><a href="../algo/" class=current>algo</a></li><li><a href="../bookz/" >bookz</a></li><li><a href="../forum/" >forum</a></li><li><a href="../about.php" >about</a></li></ul></td><td class=content><h1>Топологическая сортировка</h1><p>Page source on a <a href="http://en.wikipedia.org/wiki/TeX">TeX</a>-like language:</p><textarea style="width:100%;height:500px">\h1{Топологическая сортировка}

Дан ориентированный граф с $n$ вершинами и $m$ рёбрами. Требуется \bf{перенумеровать} его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим.

Иными словами, требуется найти перестановку вершин (\bf{топологический порядок}), соответствующую порядку, задаваемому всеми рёбрами графа.

Топологическая сортировка может быть \bf{не единственной} (например, если граф --- пустой; или если есть три такие вершины $a$, $b$, $c$, что из $a$ есть пути в $b$ и в $c$, но ни из $b$ в $c$, ни из $c$ в $b$ добраться нельзя).

Топологической сортировки может \bf{не существовать} вовсе --- если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот).

\bf{Распространённая задача} на топологическую сортировку --- следующая. Есть $n$ переменных, значения которых нам неизвестны. Известно лишь про некоторые пары переменных, что одна переменная меньше другой. Требуется проверить, не противоречивы ли эти неравенства, и если нет, выдать переменные в порядке их возрастания (если решений несколько --- выдать любое). Легко заметить, что это в точности и есть задача о поиске топологической сортировки в графе из $n$ вершин.


\h2{Алгоритм}

Для решения воспользуемся \algohref=dfs{обходом в глубину}.

Предположим, что граф ацикличен, т.е. решение существует. Что делает обход в глубину? При запуске из какой-то вершины $v$ он пытается запуститься вдоль всех рёбер, исходящих из $v$. Вдоль тех рёбер, концы которых уже были посещены ранее, он не проходит, а вдоль всех остальных --- проходит и вызывает себя от их концов.

Таким образом, к моменту выхода из вызова ${\rm dfs}(v)$ все вершины, достижимые из $v$ как непосредственно (по одному ребру), так и косвенно (по пути) --- все такие вершины уже посещены обходом. Следовательно, если мы будем в момент выхода из ${\rm dfs}(v)$ добавлять нашу вершину в начало некоего списка, то в конце концов в этом списке получится \bf{топологическая сортировка}.

Эти объяснения можно представить и в несколько ином свете, с помощью понятия \bf{"времени выхода"} обхода в глубину. Время выхода для каждой вершины $v$ --- это момент времени, в который закончил работать вызов ${\rm dfs}(v)$ обхода в глубину от неё (времена выхода можно занумеровать от $1$ до $n$). Легко понять, что при обходе в глубину время выхода из какой-либо вершины $v$ всегда больше, чем время выхода из всех вершин, достижимых из неё (т.к. они были посещены либо до вызова ${\rm dfs}(v)$, либо во время него). Таким образом, искомая топологическая сортировка --- это сортировка в порядке убывания времён выхода.


\h2{Реализация}

Приведём реализацию, предполагающую, что граф ацикличен, т.е. искомая топологическая сортировка существует. При необходимости проверку графа на ацикличность легко вставить в обход в глубину, как описано в \algohref=dfs{статье по обходу в глубину}.

\code
int n; // число вершин
vector<int> g[MAXN]; // граф
bool used[MAXN];
vector<int> ans;

void dfs (int v) {
	used[v] = true;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (!used[to])
			dfs (to);
	}
	ans.push_back (v);
}

void topological_sort() {
	for (int i=0; i<n; ++i)
		used[i] = false;
	ans.clear();
	for (int i=0; i<n; ++i)
		if (!used[i])
			dfs (i);
	reverse (ans.begin(), ans.end());
}
\endcode

Здесь константе $\rm MAXN$ следует задать значение, равное максимально возможному числу вершин в графе.

Основная функция решения --- это topological_sort, она инициализирует пометки обхода в глубину, запускает его, и ответ в итоге получается в векторе $\rm ans$.


\h2{Задачи в online judges}

Список задач, в которых требуется искать топологическую сортировку:

\ul{

\li \href=http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246{UVA #10305 \bf{"Ordering Tasks"} ~~~~ [сложность: низкая]}

\li \href=http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=60{UVA #124 \bf{"Following Orders"} ~~~~ [сложность: низкая]}

\li \href=http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136{UVA #200 \bf{"Rare Order"} ~~~~ [сложность: низкая]}



}

</textarea></td></tr></table></body></html>