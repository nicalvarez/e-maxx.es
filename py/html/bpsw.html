<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Тест BPSW на простоту чисел</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="/data/jquery.js"></script><script type="text/javascript" src="/data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php" >home</a></li><li><a href="../algo/" class=current>algo</a></li><li><a href="../bookz/" >bookz</a></li><li><a href="../forum/" >forum</a></li><li><a href="../about.php" >about</a></li></ul></td><td class=content><h1>Тест BPSW на простоту чисел</h1><p>Page source on the <a href="http://en.wikipedia.org/wiki/HTML">HTML</a> language:</p><textarea style="width:100%;height:500px">&lt;h1&gt;тест BPSW на простоту чисел&lt;/h1&gt;

&lt;hr&gt;

&lt;h2&gt;Введение&lt;/h2&gt;
&lt;p&gt;Алгоритм BPSW - это тест числа на простоту. Этот алгоритм назван по фамилиям его изобретателей: Роберт Бэйли (Ballie), Карл Померанс (Pomerance), Джон Селфридж (Selfridge), Сэмюэль Вагстафф (Wagstaff). Алгоритм был предложен в 1980 году. На сегодняшний день к алгоритму не было найдено ни одного контрпримера, равно как и не было найдено доказательство.&lt;/p&gt;
&lt;p&gt;Алгоритм BPSW был проверен на всех числах до 10&lt;sup&gt;15&lt;/sup&gt;. Кроме того, контрпример пытались найти с помощью программы PRIMO (см. &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt;), основанной на тесте на простоту с помощью эллиптических кривых. Программа, проработав три года, не нашла ни одного контрпримера, на основании чего Мартин предположил, что не существует ни одного BPSW-псевдопростого, меньшего 10&lt;sup&gt;10000&lt;/sup&gt; (псевдопростое число - составное число, на котором алгоритм даёт результат &quot;простое&quot;). В то же время, Карл Померанс в 1984 году представил эвристическое доказательство того, что существует бесконечное множество BPSW-псевдопростых чисел.&lt;/p&gt;
&lt;p&gt;Сложность алгоритма BPSW есть O (log&lt;sup&gt;3&lt;/sup&gt;(N)) битовых операций. Если же сравнивать алгоритм BPSW с другими тестами, например, тестом Миллера-Рабина, то алгоритм BPSW обычно оказывается в 3-7 раз медленнее.&lt;/p&gt;
&lt;p&gt;Алгоритм нередко применяется на практике. По-видимому, многие коммерческие математические пакеты, полностью или частично, полагаются на алгоритм BPSW для проверки чисел на простоту.&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;Краткое описание&lt;/h2&gt;
&lt;p&gt;Алгоритм имеет несколько различных реализаций, отличающихся друг от друга только деталями. В нашем случае алгоритм имеет вид:&lt;/p&gt;
&lt;p&gt;1. Выполнить тест Миллера-Рабина по основанию 2.&lt;/p&gt;
&lt;p&gt;2. Выполнить сильный тест Лукаса-Селфриджа, используя последовательности Лукаса с параметрами Селфриджа.&lt;/p&gt;
&lt;p&gt;3. Вернуть &quot;простое&quot; только в том случае, когда оба теста вернули &quot;простое&quot;.&lt;/p&gt;
&lt;p&gt;+0. Кроме того, в начало алгоритма можно добавить проверку на тривиальные делители, скажем, до 1000. Это позволит увеличить скорость работы на составных числах, правда, несколько замедлив алгоритм на простых.&lt;/p&gt;
&lt;p&gt;Итак, алгоритм BPSW основывается на следующем:&lt;/p&gt;
&lt;p&gt;1. (факт) тест Миллера-Рабина и тест Лукаса-Селфриджа если и ошибаются, то только в одну сторону: некоторые составные числа этими алгоритмами опознаются как простые. В обратную сторону эти алгоритмы не ошибаются никогда.&lt;/p&gt;
&lt;p&gt;2. (предположение) тест Миллера-Рабина и тест Лукаса-Селфриджа если и ошибаются, то никогда не ошибаются на одном числе одновременно.&lt;/p&gt;
&lt;p&gt;На самом деле, второе предположение вроде бы как и неверно - эвристическое доказательство-опровержение Померанса приведено ниже. Тем не менее, на практике ни одного псевдопростого до сих пор не нашли, поэтому условно можно считать второе предположение верным.&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;Реализация алгоритмов в данной статье&lt;/h2&gt;
&lt;p&gt;Все алгоритмы в данной статье будут реализованы на C++. Все программы тестировались только на компиляторе Microsoft C++ 8.0 SP1 (2005), также должны компилироваться на g++.&lt;/p&gt;
&lt;p&gt;Алгоритмы реализованы с использованием шаблонов (templates), что позволяет применять их как к встроенным числовым типам, так и собственным классам, реализующим длинную арифметику. [ пока длинная арифметика в статью не входит - TODO ]&lt;/p&gt;
&lt;p&gt;В самой статье будут приведены только самые существенные функции, тексты же вспомогательных функций можно скачать в приложении к статье. Здесь будут приведены только заголовки этих функций вместе с комментариями:&lt;/p&gt;
&lt;code&gt;//! Модуль 64-битного числа
long long &lt;b&gt;abs&lt;/b&gt; (long long n);
unsigned long long abs (unsigned long long n);

//! Возвращает true, если n четное
template &amp;lt;class T&gt;
bool &lt;b&gt;even&lt;/b&gt; (const T &amp; n);

//! Делит число на 2
template &amp;lt;class T&gt;
void &lt;b&gt;bisect&lt;/b&gt; (T &amp; n);

//! Умножает число на 2
template &amp;lt;class T&gt;
void &lt;b&gt;redouble&lt;/b&gt; (T &amp; n);

//! Возвращает true, если n - точный квадрат простого числа
template &amp;lt;class T&gt;
bool &lt;b&gt;perfect_square&lt;/b&gt; (const T &amp; n);

//! Вычисляет корень из числа, округляя его вниз
template &amp;lt;class T&gt;
T &lt;b&gt;sq_root&lt;/b&gt; (const T &amp; n);

//! Возвращает количество бит в числе
template &amp;lt;class T&gt;
unsigned &lt;b&gt;bits_in_number&lt;/b&gt; (T n);

//! Возвращает значение k-го бита числа (биты нумеруются с нуля)
template &amp;lt;class T&gt;
bool &lt;b&gt;test_bit&lt;/b&gt; (const T &amp; n, unsigned k);

//! Умножает a *= b (mod n)
template &amp;lt;class T&gt;
void &lt;b&gt;mulmod&lt;/b&gt; (T &amp; a, T b, const T &amp; n);

//! Вычисляет a^k (mod n)
template &amp;lt;class T, class T2&gt;
T &lt;b&gt;powmod&lt;/b&gt; (T a, T2 k, const T &amp; n);

//! Переводит число n в форму q*2^p
template &amp;lt;class T&gt;
void &lt;b&gt;transform_num&lt;/b&gt; (T n, T &amp; p, T &amp; q);

//! Алгоритм Евклида
template &amp;lt;class T, class T2&gt;
T &lt;b&gt;gcd&lt;/b&gt; (const T &amp; a, const T2 &amp; b);

//! Вычисляет jacobi(a,b) - символ Якоби
template &amp;lt;class T&gt;
T &lt;b&gt;jacobi&lt;/b&gt; (T a, T b)

//! Вычисляет pi(b) первых простых чисел. Возвращает вектор с простыми и в pi - pi(b)
template &amp;lt;class T, class T2&gt;
const std::vector&lt;T&gt; &amp; &lt;b&gt;get_primes&lt;/b&gt; (const T &amp; b, T2 &amp; pi);

//! Тривиальная проверка n на простоту, перебираются все делители до m.
//! Результат: 1 - если n точно простое, p - его найденный делитель, 0 - если неизвестно
template &amp;lt;class T, class T2&gt;
T2 &lt;b&gt;prime_div_trivial&lt;/b&gt; (const T &amp; n, T2 m);&lt;/code&gt;

&lt;hr&gt;

&lt;h2&gt;Тест Миллера-Рабина&lt;/h2&gt;
&lt;p&gt;Я не буду заострять внимание на тесте Миллера-Рабина, поскольку он описывается во многих источниках, в том числе и на русском языке (например. см. &lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Замечу лишь, что скорость его работы есть O (log&lt;sup&gt;3&lt;/sup&gt;(N)) битовых операций и приведу готовую реализацию этого алгоритма:&lt;/p&gt;
&lt;code&gt;template &amp;lt;class T, class T2&gt;
bool miller_rabin (T n, T2 b)
{

	// сначала проверяем тривиальные случаи
	if (n == 2)
		return true;
	if (n &amp;lt; 2 || even (n))
		return false;

	// проверяем, что n и b взаимно просты (иначе это приведет к ошибке)
	// если они не взаимно просты, то либо n не просто, либо нужно увеличить b
	if (b &amp;lt; 2)
		b = 2;
	for (T g; (g = gcd (n, b)) != 1; ++b)
		if (n &gt; g)
			return false;

	// разлагаем n-1 = q*2^p
	T n_1 = n;
	--n_1;
	T p, q;
	transform_num (n_1, p, q);

	// вычисляем b^q mod n, если оно равно 1 или n-1, то n простое (или псевдопростое)
	T rem = powmod (T(b), q, n);
	if (rem == 1 || rem == n_1)
		return true;

	// теперь вычисляем b^2q, b^4q, ... , b^((n-1)/2)
	// если какое-либо из них равно n-1, то n простое (или псевдопростое)
	for (T i=1; i&amp;lt;p; i++)
	{
		mulmod (rem, rem, n);
		if (rem == n_1)
			return true;
	}

	return false;

}&lt;/code&gt;

&lt;hr&gt;

&lt;h2&gt;Сильный тест Лукаса-Селфриджа&lt;/h2&gt;
&lt;p&gt;Сильный тест Лукаса-Селфриджа состоит из двух частей: алгоритма Селфриджа для вычисления некоторого параметра, и сильного алгоритма Лукаса, выполняемого с этим параметром.&lt;/p&gt;
&lt;h3&gt;Алгоритм Селфриджа&lt;/h3&gt;
&lt;p&gt;Среди последовательности 5, -7, 9, -11, 13, ... найти первое число D, для которого J (D, N) = -1 и gcd (D, N) = 1, где J(x,y) - символ Якоби.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Параметрами Селфриджа&lt;/b&gt; будут P = 1 и Q = (1 - D) / 4.&lt;/p&gt;
&lt;p&gt;Следует заметить, что параметр Селфриджа не существует для чисел, которые являются точными квадратами. Действительно, если число является точным квадратом, то перебор D дойдёт до sqrt(N), на котором окажется, что gcd (D, N) &gt; 1, т.е. обнаружится, что число N составное.&lt;/p&gt;
&lt;p&gt;Кроме того, параметры Селфриджа будут вычислены неправильно для чётных чисел и для единицы; впрочем, проверка этих случаев не составит труда.&lt;/p&gt;
&lt;p&gt;Таким образом, &lt;b&gt;перед началом алгоритма&lt;/b&gt; следует проверить, что число N является нечётным, большим 2, и не является точным квадратом, иначе (при невыполнении хотя бы одного условия) нужно сразу выйти из алгоритма с результатом &quot;составное&quot;.&lt;/p&gt;
&lt;p&gt;Наконец, заметим, что если D для некоторого числа N окажется слишком большим, то алгоритм с вычислительной точки зрения окажется неприменимым. Хотя на практике такого замечено не было (оказывалось вполне достаточно 4-байтного числа), тем не менее вероятность этого события не следует исключать. Впрочем, например, на отрезке [1; 10&lt;sup&gt;6&lt;/sup&gt;] max(D) = 47, а на отрезке [10&lt;sup&gt;19&lt;/sup&gt;; 10&lt;sup&gt;19&lt;/sup&gt;+10&lt;sup&gt;6&lt;/sup&gt;] max(D) = 67. Кроме того, Бэйли и Вагстаф в 1980 году аналитически доказали это наблюдение (см. Ribenboim, 1995/96, стр. 142).&lt;/p&gt;
&lt;h3&gt;Сильный алгоритм Лукаса&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Параметрами алгоритма&lt;/b&gt; Лукаса являются числа &lt;b&gt;D, P и Q&lt;/b&gt; такие, что D = P&lt;sup&gt;2&lt;/sup&gt; - 4*Q ? 0, и P &gt; 0.&lt;/p&gt;
&lt;p&gt;(нетрудно заметить, что параметры, вычисленные по алгоритму Селфриджа, удовлетворяют этим условиям)&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Последовательности Лукаса&lt;/b&gt; - это последовательности U&lt;sub&gt;k&lt;/sub&gt; и V&lt;sub&gt;k&lt;/sub&gt;, определяемые следующим образом:&lt;/p&gt;
&lt;formula&gt;U&lt;sub&gt;0&lt;/sub&gt; = 0
U&lt;sub&gt;1&lt;/sub&gt; = 1
&lt;b&gt;U&lt;sub&gt;k&lt;/sub&gt; = P U&lt;sub&gt;k-1&lt;/sub&gt; - Q U&lt;sub&gt;k-2&lt;/sub&gt;&lt;/b&gt;
V&lt;sub&gt;0&lt;/sub&gt; = 2
V&lt;sub&gt;1&lt;/sub&gt; = P
&lt;b&gt;V&lt;sub&gt;k&lt;/sub&gt; = P V&lt;sub&gt;k-1&lt;/sub&gt; - Q V&lt;sub&gt;k-2&lt;/sub&gt;&lt;/b&gt;&lt;/formula&gt;
&lt;p&gt;Далее, пусть M = N - J (D, N).&lt;/p&gt;
&lt;p&gt;Если N простое, и gcd (N, Q) = 1, то имеем:&lt;/p&gt;
&lt;formula&gt;&lt;b&gt;U&lt;sub&gt;M&lt;/sub&gt; = 0 (mod N)&lt;/b&gt;&lt;/formula&gt;
&lt;p&gt;В частности, когда параметры D, P, Q вычислены алгоритмом Селфриджа, имеем:&lt;/p&gt;
&lt;formula&gt;U&lt;sub&gt;N+1&lt;/sub&gt; = 0 (mod N)&lt;/b&gt;&lt;/formula&gt;
&lt;p&gt;Обратное, вообще говоря, неверно. Тем не менее, псевдопростых чисел при данном алгоритме оказывается не очень много, на чём, собственно, и основывается алгоритм Лукаса.&lt;/p&gt;
&lt;p&gt;Итак, &lt;b&gt;алгоритм Лукаса заключается в вычислении U&lt;sub&gt;M&lt;/sub&gt; и сравнении его с нулём&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Далее, необходимо найти какой-то способ ускорения вычисления U&lt;sub&gt;K&lt;/sub&gt;, иначе, понятно, никакого практического смысла в этом алгоритма не было бы.&lt;/p&gt;
&lt;p&gt;Имеем:&lt;/p&gt;
&lt;formula&gt;U&lt;sub&gt;k&lt;/sub&gt; = (a&lt;sup&gt;k&lt;/sup&gt; - b&lt;sup&gt;k&lt;/sup&gt;) / (a - b),
V&lt;sub&gt;k&lt;/sub&gt; = a&lt;sup&gt;k&lt;/sup&gt; + b&lt;sup&gt;k&lt;/sup&gt;,&lt;/formula&gt;
&lt;p&gt;где a и b - различные корни квадратного уравнения x&lt;sup&gt;2&lt;/sup&gt; - P x + Q = 0.&lt;/p&gt;
&lt;p&gt;Теперь следующие равенства можно доказать элементарно:&lt;/p&gt;
&lt;formula&gt;U&lt;sub&gt;2k&lt;/sub&gt; = U&lt;sub&gt;k&lt;/sub&gt; V&lt;sub&gt;k&lt;/sub&gt; (mod N)
V&lt;sub&gt;2k&lt;/sub&gt; = V&lt;sub&gt;k&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; - 2 Q&lt;sup&gt;k&lt;/sup&gt; (mod N)&lt;/formula&gt;
&lt;p&gt;Теперь, если представить M = E 2&lt;sup&gt;T&lt;/sup&gt;, где E - нечётное число, то легко получить:&lt;/p&gt;
&lt;formula&gt;&lt;b&gt;U&lt;sub&gt;M&lt;/sub&gt; = U&lt;sub&gt;E&lt;/sub&gt; V&lt;sub&gt;E&lt;/sub&gt; V&lt;sub&gt;2E&lt;/sub&gt; V&lt;sub&gt;4E&lt;/sub&gt; ... V&lt;sub&gt;2&lt;sup&gt;T-2&lt;/sup&gt;E&lt;/sub&gt; V&lt;sub&gt;2&lt;sup&gt;T-1&lt;/sup&gt;E&lt;/sub&gt; = 0 (mod N)&lt;/b&gt;,&lt;/formula&gt;
&lt;p&gt;и хотя бы один из множителей равен нулю по модулю N.&lt;/p&gt;
&lt;p&gt;Понятно, что &lt;b&gt;достаточно вычислить U&lt;sub&gt;E&lt;/sub&gt; и V&lt;sub&gt;E&lt;/sub&gt;&lt;/b&gt;, а все последующие множители V&lt;sub&gt;2E&lt;/sub&gt; V&lt;sub&gt;4E&lt;/sub&gt; ... V&lt;sub&gt;2&lt;sup&gt;T-2&lt;/sup&gt;E&lt;/sub&gt; V&lt;sub&gt;2&lt;sup&gt;T-1&lt;/sup&gt;E&lt;/sub&gt; можно &lt;b&gt;получить уже из них&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Таким образом, осталось научиться быстро вычислять U&lt;sub&gt;E&lt;/sub&gt; и V&lt;sub&gt;E&lt;/sub&gt; для нечётного E.&lt;/p&gt;
&lt;p&gt;Сначала рассмотрим следующие формулы для сложения членов последовательностей Лукаса:&lt;/p&gt;
&lt;formula&gt;U&lt;sub&gt;i+j&lt;/sub&gt; = (U&lt;sub&gt;i&lt;/sub&gt; V&lt;sub&gt;j&lt;/sub&gt; + U&lt;sub&gt;j&lt;/sub&gt; V&lt;sub&gt;i&lt;/sub&gt;) / 2 (mod N)
V&lt;sub&gt;i+j&lt;/sub&gt; = (V&lt;sub&gt;i&lt;/sub&gt; V&lt;sub&gt;j&lt;/sub&gt; + D U&lt;sub&gt;i&lt;/sub&gt; U&lt;sub&gt;j&lt;/sub&gt;) / 2 (mod N)&lt;/formula&gt;
&lt;p&gt;Следует обратить внимание, что деление выполняется в поле (mod N).&lt;/p&gt;
&lt;p&gt;Формулы эти доказываются очень просто, и здесь их доказательство опущено.&lt;/p&gt;
&lt;p&gt;Теперь, обладая формулами для сложения и для удвоения членов последовательностей Лукаса, понятен и способ ускорения вычисления U&lt;sub&gt;E&lt;/sub&gt; и V&lt;sub&gt;E&lt;/sub&gt;.&lt;/p&gt;
&lt;p&gt;Действительно, рассмотрим двоичную запись числа E. Положим сначала результат - U&lt;sub&gt;E&lt;/sub&gt; и V&lt;sub&gt;E&lt;/sub&gt; - равными, соответственно, U&lt;sub&gt;1&lt;/sub&gt; и V&lt;sub&gt;1&lt;/sub&gt;. Пройдёмся по всем битам числа E от более младших к более старшим, пропустив только самый первый бит (начальный член последовательности). Для каждого i-го бита будем вычислять U&lt;sub&gt;2&lt;sup&gt; i&lt;/sup&gt;&lt;/sub&gt; и V&lt;sub&gt;2&lt;sup&gt; i&lt;/sup&gt;&lt;/sub&gt; из предыдущих членов с помощью формул удвоения. Кроме того, если текущий i-ый бит равен единице, то к ответу будем прибавлять текущие U&lt;sub&gt;2&lt;sup&gt; i&lt;/sup&gt;&lt;/sub&gt; и V&lt;sub&gt;2&lt;sup&gt; i&lt;/sup&gt;&lt;/sub&gt; с помощью формул сложения. По окончании алгоритма, выполняющегося за O (log(E)), мы &lt;b&gt;получим искомые U&lt;sub&gt;E&lt;/sub&gt; и V&lt;sub&gt;E&lt;/sub&gt;&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Если U&lt;sub&gt;E&lt;/sub&gt; или V&lt;sub&gt;E&lt;/sub&gt; оказались равными нулю (mod N), то число N простое (или псевдопростое). Если они оба отличны от нуля, то вычисляем V&lt;sub&gt;2E&lt;/sub&gt;, V&lt;sub&gt;4E&lt;/sub&gt;, ... V&lt;sub&gt;2&lt;sup&gt;T-2&lt;/sup&gt;E&lt;/sub&gt;, V&lt;sub&gt;2&lt;sup&gt;T-1&lt;/sup&gt;E&lt;/sub&gt;. Если хотя бы один из них сравним с нулём по модулю N, то число N простое (или псевдопростое). Иначе число N составное.&lt;/p&gt;
&lt;h3&gt;Обсуждение алгоритма Селфриджа&lt;/h3&gt;
&lt;p&gt;Теперь, когда мы рассмотрели алгоритм Лукаса, можно более подробно остановиться на его параметрах D,P,Q, одним из способов получения которых и является алгоритм Селфриджа.&lt;/p&gt;
&lt;p&gt;Напомним базовые требования к параметрам:&lt;/p&gt;
&lt;formula&gt;&lt;b&gt;P &gt; 0&lt;/b&gt;,
&lt;b&gt;D = P&lt;sup&gt;2&lt;/sup&gt; - 4*Q ? 0&lt;/b&gt;.&lt;/formula&gt;
&lt;p&gt;Теперь продолжим изучение этих параметров.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;D не должно быть точным квадратом (mod N)&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Действительно, иначе получим:&lt;/p&gt;
&lt;p&gt;D = b&lt;sup&gt;2&lt;/sup&gt;, отсюда J(D,N) = 1, P = b + 2, Q = b + 1, отсюда U&lt;sub&gt;n-1&lt;/sub&gt; = (Q&lt;sup&gt;n-1&lt;/sup&gt; - 1) / (Q - 1).&lt;/p&gt;
&lt;p&gt;Т.е. если D - точный квадрат, то алгоритм Лукаса становится практически обычным вероятностным тестом.&lt;/p&gt;
&lt;p&gt;Один из лучших способов избежать подобного - &lt;b&gt;потребовать, чтобы J(D,N) = -1&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Например, можно выбрать первое число D из последовательности 5, -7, 9, -11, 13, ..., для которого J(D,N) = -1. Также пусть P = 1. Тогда Q = (1 - D) / 4. Этот способ был предложен Селфриджем.&lt;/p&gt;
&lt;p&gt;Впрочем, имеются и другие способы выбора D. Можно выбирать его из последовательности 5, 9, 13, 17, 21, ... Также пусть P - наименьшее нечётное, привосходящее sqrt(D). Тогда Q = (P&lt;sup&gt;2&lt;/sup&gt; - D) / 4.&lt;/p&gt;
&lt;p&gt;Понятно, что от выбора конкретного способа вычисления параметров Лукаса зависит и его результат - псевдопростые могут отличаться при различных способах выбора параметра. Как показала практика, алгоритм, предложенный Селфриджем, оказался очень удачным: все псевдопростые Лукаса-Селфриджа не являются псевдопростыми Миллера-Рабина, по крайней мере, ни одного контрпримера найдено не было.&lt;/p&gt;
&lt;h3&gt;Реализация сильного алгоритма Лукаса-Селфриджа&lt;/h3&gt;
&lt;p&gt;Теперь осталось только реализовать алгоритм:&lt;/p&gt;
&lt;code&gt;template &amp;lt;class T, class T2&gt;
bool lucas_selfridge (const T &amp; n, T2 unused)
{

	// сначала проверяем тривиальные случаи
	if (n == 2)
		return true;
	if (n &amp;lt; 2 || even (n))
		return false;

	// проверяем, что n не является точным квадратом, иначе алгоритм даст ошибку
	if (perfect_square (n))
		return false;

	// алгоритм Селфриджа: находим первое число d такое, что:
	// jacobi(d,n)=-1 и оно принадлежит ряду { 5,-7,9,-11,13,... }
	T2 dd;
	for (T2 d_abs = 5, d_sign = 1; ; d_sign = -d_sign, ++++d_abs)
	{
		dd = d_abs * d_sign;
		T g = gcd (n, d_abs);
		if (1 &amp;lt; g &amp;&amp; g &amp;lt; n)
			// нашли делитель - d_abs
			return false;
		if (jacobi (T(dd), n) == -1)
			break;
	}

	// параметры Селфриджа
	T2
		p = 1,
		q = (p*p - dd) / 4;
	
	// разлагаем n+1 = d*2^s
	T n_1 = n;
	++n_1;
	T s, d;
	transform_num (n_1, s, d);

	// алгоритм Лукаса
	T
		u = 1,
		v = p,
		u2m = 1,
		v2m = p,
		qm = q,
		qm2 = q*2,
		qkd = q;
	for (unsigned bit = 1, bits = bits_in_number(d); bit &amp;lt; bits; bit++)
	{
		mulmod (u2m, v2m, n);
		mulmod (v2m, v2m, n);
		while (v2m &lt; qm2)
			v2m += n;
		v2m -= qm2;
		mulmod (qm, qm, n);
		qm2 = qm;
		redouble (qm2);
		if (test_bit (d, bit))
		{
			T t1, t2;
			t1 = u2m;
			mulmod (t1, v, n);
			t2 = v2m;
			mulmod (t2, u, n);
			
			T t3, t4;
			t3 = v2m;
			mulmod (t3, v, n);
			t4 = u2m;
			mulmod (t4, u, n);
			mulmod (t4, (T)dd, n);

			u = t1 + t2;
			if (!even (u))
				u += n;
			bisect (u);
			u %= n;

			v = t3 + t4;
			if (!even (v))
				v += n;
			bisect (v);
			v %= n;
			mulmod (qkd, qm, n);
		}
	}

	// точно простое (или псевдо-простое)
	if (u == 0 || v == 0)
		return true;

	// довычисляем оставшиеся члены
	T qkd2 = qkd;
	redouble (qkd2);
	for (T2 r = 1; r &amp;lt; s; ++r)
	{
		mulmod (v, v, n);
		v -= qkd2;
		if (v &amp;lt; 0) v += n;
		if (v &amp;lt; 0) v += n;
		if (v &gt;= n) v -= n;
		if (v &gt;= n) v -= n;
		if (v == 0)
			return true;
		if (r &amp;lt; s-1)
		{
			mulmod (qkd, qkd, n);
			qkd2 = qkd;
			redouble (qkd2);
		}
	}

	return false;

}&lt;/code&gt;

&lt;hr&gt;

&lt;h2&gt;Код BPSW&lt;/h2&gt;
&lt;p&gt;Теперь осталось просто скомбинировать результаты всех 3 тестов: проверка на небольшие тривиальные делители, тест Миллера-Рабина, сильный тест Лукаса-Селфриджа.&lt;/p&gt;
&lt;code&gt;template &amp;lt;class T&gt;
bool baillie_pomerance_selfridge_wagstaff (T n)
{

	// сначала проверяем на тривиальные делители - например, до 29
	int div = prime_div_trivial (n, 29);
	if (div == 1)
		return true;
	if (div &gt; 1)
		return false;

	// тест Миллера-Рабина по основанию 2
	if (!miller_rabin (n, 2))
		return false;

	// сильный тест Лукаса-Селфриджа
	return lucas_selfridge (n, 0);

}&lt;/code&gt;
&lt;p&gt;&lt;a href=BPSW_main.zip&gt;Отсюда&lt;/a&gt; можно скачать программу (исходник + exe), содержащую полную реализацию теста BPSW. [77 КБ]&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;Краткая реализация&lt;/h2&gt;
&lt;p&gt;Длину кода можно значительно уменьшить в ущерб универсальности, отказавшись от шаблонов и различных вспомогательных функций.&lt;/p&gt;
&lt;code&gt;const int trivial_limit = 50;
int p[1000];

int gcd (int a, int b) {
	return a ? gcd (b%a, a) : b;
}

int powmod (int a, int b, int m) {
	int res = 1;
	while (b)
		if (b &amp; 1)
			res = (res * 1ll * a) % m,  --b;
		else
			a = (a * 1ll * a) % m,  b &gt;&gt;= 1;
	return res;
}

bool miller_rabin (int n) {
	int b = 2;
	for (int g; (g = gcd (n, b)) != 1; ++b)
		if (n &gt; g)
			return false;
	int p=0, q=n-1;
	while ((q &amp; 1) == 0)
		++p,  q &gt;&gt;= 1;
	int rem = powmod (b, q, n);
	if (rem == 1 || rem == n-1)
		return true;
	for (int i=1; i&amp;lt;p; ++i) {
		rem = (rem * 1ll * rem) % n;
		if (rem == n-1)  return true;
	}
	return false;
}

int jacobi (int a, int b)
{
	if (a == 0)  return 0;
	if (a == 1)  return 1;
	if (a &amp;lt; 0)
		if ((b &amp; 2) == 0)
			return jacobi (-a, b);
		else
			return - jacobi (-a, b);
	int a1=a,  e=0;
	while ((a1 &amp; 1) == 0)
		a1 &gt;&gt;= 1,  ++e;
	int s;
	if ((e &amp; 1) == 0 || (b &amp; 7) == 1 || (b &amp; 7) == 7)
		s = 1;
	else
		s = -1;
	if ((b &amp; 3) == 3 &amp;&amp; (a1 &amp; 3) == 3)
		s = -s;
	if (a1 == 1)
		return s;
	return s * jacobi (b % a1, a1);
}

bool bpsw (int n) {
	if ((int)sqrt(n+0.0) * (int)sqrt(n+0.0) == n)  return false;
	int dd=5;
	for (;;) {
		int g = gcd (n, abs(dd));
		if (1&amp;lt;g &amp;&amp; g&amp;lt;n)  return false;
		if (jacobi (dd, n) == -1)  break;
		dd = dd&amp;lt;0 ? -dd+2 : -dd-2;
	}
	int p=1,  q=(p*p-dd)/4;
	int d=n+1,  s=0;
	while ((d &amp; 1) == 0)
		++s,  d&gt;&gt;=1;
	long long u=1, v=p, u2m=1, v2m=p, qm=q, qm2=q*2, qkd=q;
	for (int mask=2; mask&amp;lt;=d; mask&amp;lt;&amp;lt;=1) {
		u2m = (u2m * v2m) % n;
		v2m = (v2m * v2m) % n;
		while (v2m &lt; qm2)   v2m += n;
		v2m -= qm2;
		qm = (qm * qm) % n;
		qm2 = qm * 2;
		if (d &amp; mask) {
			long long t1 = (u2m * v) % n,  t2 = (v2m * u) % n,
				t3 = (v2m * v) % n,  t4 = (((u2m * u) % n) * dd) % n;
			u = t1 + t2;
			if (u &amp; 1)  u += n;
			u = (u &gt;&gt; 1) % n;
			v = t3 + t4;
			if (v &amp; 1)  v += n;
			v = (v &gt;&gt; 1) % n;
			qkd = (qkd * qm) % n;
		}
	}
	if (u==0 || v==0)  return true;
	long long qkd2 = qkd*2;
	for (int r=1; r&amp;lt;s; ++r) {
		v = (v * v) % n - qkd2;
		if (v &amp;lt; 0)  v += n;
		if (v &amp;lt; 0)  v += n;
		if (v &gt;= n)  v -= n;
		if (v &gt;= n)  v -= n;
		if (v == 0)  return true;
		if (r &amp;lt; s-1) {
			qkd = (qkd * 1ll * qkd) % n;
			qkd2 = qkd * 2;
		}
	}
	return false;
}

bool prime (int n) { // эту функцию нужно вызывать для проверки на простоту
	for (int i=0; i&amp;lt;trivial_limit &amp;&amp; p[i]&amp;lt;n; ++i)
		if (n % p[i] == 0)
			return false;
	if (p[trivial_limit-1]*p[trivial_limit-1] &gt;= n)
		return true;
	if (!miller_rabin (n))
		return false;
	return bpsw (n);
}

void prime_init() { // вызвать до первого вызова prime() !
	for (int i=2, j=0; j&amp;lt;trivial_limit; ++i) {
		bool pr = true;
		for (int k=2; k*k&amp;lt;=i; ++k)
			if (i % k == 0)
				pr = false;
		if (pr)
			p[j++] = i;
	}
}&lt;/code&gt;

&lt;hr&gt;

&lt;h2&gt;Эвристическое доказательство-опровержение Померанса&lt;/h2&gt;
&lt;p&gt;Померанс в 1984 году предложил следующее эвристическое доказательство.&lt;/p&gt;
&lt;p&gt;Утверждение: &lt;b&gt;Количество BPSW-псевдопростых от 1 до X больше X&lt;sup&gt;1-a&lt;/sup&gt; для любого a &gt; 0&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Доказательство.&lt;/p&gt;
&lt;p&gt;Пусть k &gt; 4 - произвольное, но фиксированное число. Пусть T - некоторое большое число.&lt;/p&gt;
&lt;p&gt;Пусть P&lt;sub&gt;k&lt;/sub&gt;(T) - множество таких простых p в интервале [T; T&lt;sup&gt;k&lt;/sup&gt;], для которых:&lt;/p&gt;
&lt;p&gt;(1) p = 3 (mod 8), J(5,p) = -1&lt;/p&gt;
&lt;p&gt;(2) число (p-1)/2 не является точным квадратом&lt;/p&gt;
&lt;p&gt;(3) число (p-1)/2 составлено исключительно из простых q &lt; T
&lt;p&gt;(4) число (p-1)/2 составлено исключительно из таких простых q, что q = 1 (mod 4)&lt;/p&gt;
&lt;p&gt;(5) число (p+1)/4 не является точным квадратом&lt;/p&gt;
&lt;p&gt;(6) число (p+1)/4 составлено исключительно из простых d &lt; T&lt;/p&gt;
&lt;p&gt;(7) число (p+1)/4 составлено исключительно из таких простых d, что q = 3 (mod 4)&lt;/p&gt;
&lt;p&gt;Понятно, что приблизительно 1/8 всех простых в отрезке [T; T&lt;sup&gt;k&lt;/sup&gt;] удовлетворяет условию (1). Также можно показать, что условия (2) и (5) сохраняют некоторую часть чисел. Эвристически, условия (3) и (6) также позволяют нам оставить некоторую часть чисел из отрезка (T; T&lt;sup&gt;k&lt;/sup&gt;). Наконец, событие (4) обладает вероятностью (c (log T)&lt;sup&gt;-1/2&lt;/sup&gt;), так же как и событие (7). Таким образом, мощность множества P&lt;sub&gt;k&lt;/sub&gt;(T) прблизительно равна при T -&gt; oo&lt;/p&gt;
&lt;p&gt;&lt;img src=BPSW_formula1.jpg&gt;&lt;/p&gt;
&lt;p&gt;где c - некоторая положительная константа, зависящая от выбора k.&lt;/p&gt;
&lt;p&gt;Теперь мы &lt;b&gt;можем построить число n&lt;/b&gt;, не являющееся точным квадратом, составленное из l простых из P&lt;sub&gt;k&lt;/sub&gt;(T), где l нечётно и меньше T&lt;sup&gt;2&lt;/sup&gt; / log(T&lt;sup&gt;k&lt;/sup&gt;). Количество способов выбрать такое число n есть примерно&lt;/p&gt;
&lt;p&gt;&lt;img src=BPSW_formula2.jpg&gt;&lt;/p&gt;
&lt;p&gt;для большого T и фиксированного k. Кроме того, каждое такое число n меньше e&lt;sup&gt;T&lt;sup&gt;2&lt;/sup&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Обозначим через Q&lt;sub&gt;1&lt;/sub&gt; произведение простых q &lt; T, для которых q = 1 (mod 4), а через Q&lt;sub&gt;3&lt;/sub&gt; - произведение простых q &lt; T, для которых q = 3 (mod 4). Тогда gcd (Q&lt;sub&gt;1&lt;/sub&gt;, Q&lt;sub&gt;3&lt;/sub&gt;) = 1 и Q&lt;sub&gt;1&lt;/sub&gt; Q&lt;sub&gt;3&lt;/sub&gt; ? e&lt;sup&gt;T&lt;/sup&gt;. Таким образом, количество способов выбрать n &lt;b&gt;с дополнительными условиями&lt;/b&gt;&lt;/p&gt;
&lt;formula&gt;n = 1 (mod Q&lt;sub&gt;1&lt;/sub&gt;), n = -1 (mod Q&lt;sub&gt;3&lt;/sub&gt;)&lt;/formula&gt;
&lt;p&gt;должно быть, эвристически, как минимум&lt;/p&gt;
&lt;formula&gt;e&lt;sup&gt;T&lt;sup&gt; 2&lt;/sup&gt; (1 - 3 / k)&lt;/sup&gt; / e&lt;sup&gt; 2T&lt;/sup&gt; &gt; &lt;b&gt;e&lt;sup&gt;T&lt;sup&gt; 2&lt;/sup&gt; (1 - 4 / k)&lt;/sup&gt;&lt;/b&gt;&lt;/formula&gt;
&lt;p&gt;для большого T.&lt;/p&gt;
&lt;p&gt;Но &lt;b&gt;каждое такое n - это контрпример к тесту BPSW&lt;/b&gt;. Действительно, n будет числом Кармайкла (т.е. числом, на котором тест Миллера-Рабина будет ошибаться при любом основании), поэтому оно автоматически будет псевдопростым по основанию 2. Поскольку n = 3 (mod 8) и каждое p | n равно 3 (mod 8), очевидно, что n также будет сильным псевдопростым по основанию 2. Поскольку J(5,n) = -1, то каждое простое p | n удовлетворяет J(5,p) = -1, и так как p+1 | n+1 для любого простого p | n, отсюда следует, что n - псевдопростое Лукаса для любого теста Лукаса с дискриминантом 5.&lt;/p&gt;
&lt;p&gt;Таким образом, мы показали, что для любого фиксированного k и всех больших T, будет как минимум e&lt;sup&gt;T&lt;sup&gt; 2&lt;/sup&gt; (1 - 4 / k)&lt;/sup&gt; контрпримеров к тесту BPSW среди чисел, меньших e&lt;sup&gt;T&lt;sup&gt; 2&lt;/sup&gt;&lt;/sup&gt;. Теперь, если мы положим x = e&lt;sup&gt;T&lt;sup&gt; 2&lt;/sup&gt;&lt;/sup&gt;, будет как минимум x&lt;sup&gt;1 - 4 / k&lt;/sup&gt; контрпримеров, меньших x. Поскольку k - случайное число, то наше доказательство означает, что &lt;b&gt;количество контрпримеров, меньших x, есть число, большее x&lt;sup&gt;1-a&lt;/sup&gt; для любого a &gt; 0&lt;/b&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;Практические испытания теста BPSW&lt;/h2&gt;
&lt;p&gt;В этом разделе будут рассмотрены результаты, полученные мной в результате тестирования моей реализации теста BPSW. Все испытания проводились на встроенном типе - 64-битном числе long long. Длинная арифметика не тестировалась.&lt;/p&gt;
&lt;p&gt;Тестирования проводились на компьютере с процессором Celeron 1.3 GHz.&lt;/p&gt;
&lt;p&gt;Все времена даны в &lt;b&gt;микросекундах&lt;/b&gt; (10&lt;sup&gt; -6&lt;/sup&gt; сек).&lt;/p&gt;

&lt;h3&gt;Среднее время работы на отрезке чисел в зависимости от предела тривиального перебора&lt;/h3&gt;
&lt;p&gt;Имеется в виду параметр, передаваемый функции prime_div_trivial(), который в коде выше равен 29.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;BPSW_test_1.zip&quot;&gt;Скачать&lt;/a&gt; тестовую программу (исходник и exe-файл). [83 КБ]&lt;/p&gt;
&lt;p&gt;Если запускать тест &lt;b&gt;на всех нечетных числах&lt;/b&gt; из отрезка, то результаты получаются такими:&lt;/p&gt;
&lt;table class=table2 cellspacing=0&gt;
&lt;tr&gt;&lt;th&gt;начало&lt;br&gt;отрезка&lt;/th&gt;&lt;th&gt;конец&lt;br&gt;отрезка&lt;/th&gt;&lt;th&gt;предел &gt;&lt;br&gt;перебора &gt;&lt;/th&gt;&lt;th width=13%&gt;0&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;2&lt;/sup&gt;&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;3&lt;/sup&gt;&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;4&lt;/sup&gt;&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;5&lt;/sup&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;8.1&lt;/td&gt;&lt;td&gt;4.5&lt;/td&gt;&lt;td&gt;0.7&lt;/td&gt;&lt;td&gt;0.7&lt;/td&gt;&lt;td&gt;0.9&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;6&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;6&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;12.8&lt;/td&gt;&lt;td&gt;6.8&lt;/td&gt;&lt;td&gt;7.0&lt;/td&gt;&lt;td&gt;1.6&lt;/td&gt;&lt;td&gt;1.6&lt;/td&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;9&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;9&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;28.4&lt;/td&gt;&lt;td&gt;12.6&lt;/td&gt;&lt;td&gt;12.1&lt;/td&gt;&lt;td&gt;17.0&lt;/td&gt;&lt;td&gt;17.1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;12&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;12&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;41.5&lt;/td&gt;&lt;td&gt;16.5&lt;/td&gt;&lt;td&gt;15.3&lt;/td&gt;&lt;td&gt;19.4&lt;/td&gt;&lt;td&gt;54.4&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;66.7&lt;/td&gt;&lt;td&gt;24.4&lt;/td&gt;&lt;td&gt;21.1&lt;/td&gt;&lt;td&gt;24.8&lt;/td&gt;&lt;td&gt;58.9&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Если запускать тест &lt;b&gt;только на простых числах&lt;/b&gt; из отрезка, то скорость работы такова:&lt;/p&gt;
&lt;table class=table2 cellspacing=0&gt;
&lt;tr&gt;&lt;th&gt;начало&lt;br&gt;отрезка&lt;/th&gt;&lt;th&gt;конец&lt;br&gt;отрезка&lt;/th&gt;&lt;th&gt;предел &gt;&lt;br&gt;перебора &gt;&lt;/th&gt;&lt;th width=13%&gt;0&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;2&lt;/sup&gt;&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;3&lt;/sup&gt;&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;4&lt;/sup&gt;&lt;/th&gt;&lt;th width=13%&gt;10&lt;sup&gt;5&lt;/sup&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;42.9&lt;/td&gt;&lt;td&gt;40.8&lt;/td&gt;&lt;td&gt;3.1&lt;/td&gt;&lt;td&gt;4.2&lt;/td&gt;&lt;td&gt;4.2&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;6&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;6&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;75.0&lt;/td&gt;&lt;td&gt;76.4&lt;/td&gt;&lt;td&gt;88.8&lt;/td&gt;&lt;td&gt;13.9&lt;/td&gt;&lt;td&gt;15.2&lt;/td&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;9&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;9&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;186.5&lt;/td&gt;&lt;td&gt;188.5&lt;/td&gt;&lt;td&gt;201.0&lt;/td&gt;&lt;td&gt;294.3&lt;/td&gt;&lt;td&gt;283.9&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;12&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;12&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;288.3&lt;/td&gt;&lt;td&gt;288.3&lt;/td&gt;&lt;td&gt;302.2&lt;/td&gt;&lt;td&gt;387.9&lt;/td&gt;&lt;td&gt;1069.5&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;485.6&lt;/td&gt;&lt;td&gt;489.1&lt;/td&gt;&lt;td&gt;496.3&lt;/td&gt;&lt;td&gt;585.4&lt;/td&gt;&lt;td&gt;1267.4&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Таким образом, оптимально выбирать &lt;b&gt;предел тривиального перебора равным 100 или 1000&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Для всех следующих тестов я выбрал предел 1000.&lt;/p&gt;

&lt;h3&gt;Среднее время работы на отрезке чисел&lt;/h3&gt;
&lt;p&gt;Теперь, когда мы выбрали предел тривиального перебора, можно более точно протестировать скорость работы на различных отрезках.&lt;/p&gt;
&lt;p&gt;&lt;a href=BPSW_test2.zip&gt;Скачать&lt;/a&gt; тестовую программу (исходник и exe-файл). [83 КБ]&lt;/p&gt;
&lt;table class=table1 cellspacing=0&gt;
&lt;tr&gt;&lt;th width=100&gt;начало&lt;br&gt;отрезка&lt;/th&gt;&lt;th width=100&gt;конец&lt;br&gt;отрезка&lt;/th&gt;&lt;th width=200&gt;время работы&lt;br&gt;на нечетных числах&lt;/th&gt;&lt;th width=200&gt;время работы&lt;br&gt;на простых числах&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;1.2&lt;/td&gt;&lt;td&gt;4.2&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;6&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;6&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;13.8&lt;/td&gt;&lt;td&gt;88.8&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;7&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;7&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;16.8&lt;/td&gt;&lt;td&gt;115.5&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;8&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;8&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;21.2&lt;/td&gt;&lt;td&gt;164.8&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;9&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;9&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;24.0&lt;/td&gt;&lt;td&gt;201.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;10&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;10&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;25.2&lt;/td&gt;&lt;td&gt;225.5&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;11&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;11&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;28.4&lt;/td&gt;&lt;td&gt;266.5&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;12&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;12&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;30.4&lt;/td&gt;&lt;td&gt;302.2&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;13&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;13&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;33.0&lt;/td&gt;&lt;td&gt;352.2&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;14&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;14&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;37.5&lt;/td&gt;&lt;td&gt;424.3&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;42.3&lt;/td&gt;&lt;td&gt;499.8&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;16&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;46.5&lt;/td&gt;&lt;td&gt;553.6&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;sup&gt;17&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;10&lt;sup&gt;15&lt;/sup&gt;+10&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;48.9&lt;/td&gt;&lt;td&gt;621.1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Или, в виде графика, приблизительное время работы теста BPSW на одном числе:&lt;/p&gt;
&lt;p&gt;&lt;img src=BPSW_graph1.gif&gt;&lt;/p&gt;
&lt;p&gt;То есть мы получили, что на практике, на небольших числах (до 10&lt;sup&gt;17&lt;/sup&gt;), &lt;b&gt;алгоритм работает за O (log N)&lt;/b&gt;. Это объясняется тем, что для встроенного типа int64 операция деления выполняется за O(1), т.е. сложность деления не зависисит от количества битов в числе.&lt;/p&gt;
&lt;p&gt;Если же применить тест BPSW к длинной арифметике, то ожидается, что он будет работать как раз за O (log&lt;sup&gt;3&lt;/sup&gt;(N)). [ TODO ]&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;Приложение. Все программы&lt;/h2&gt;
&lt;p&gt;&lt;a href=BPSW_all.zip&gt;Скачать&lt;/a&gt; все программы из данной статьи. [242 КБ]&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;Литература&lt;/h2&gt;
&lt;p&gt;Использованная мной литература, полностью доступная в Интернете:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Robert Baillie; Samuel S. Wagstaff&lt;br&gt;&lt;b&gt;Lucas pseudoprimes&lt;/b&gt;&lt;br&gt;Math. Comp. 35 (1980) 1391-1417&lt;br&gt;&lt;a href=&quot;http://mpqs.free.fr/LucasPseudoprimes.pdf&quot;&gt;mpqs.free.fr/LucasPseudoprimes.pdf&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Daniel J. Bernstein&lt;br&gt;&lt;b&gt;Distinguishing prime numbers from composite numbers: the state of the art in 2004&lt;/b&gt;&lt;br&gt;Math. Comp. (2004)&lt;br&gt;&lt;a href=&quot;http://cr.yp.to/primetests/prime2004-20041223.pdf&quot;&gt;cr.yp.to/primetests/prime2004-20041223.pdf&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Richard P. Brent&lt;br&gt;&lt;b&gt;Primality Testing and Integer Factorisation&lt;/b&gt;&lt;br&gt;The Role of Mathematics in Science (1990)&lt;br&gt;&lt;a href=&quot;http://wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf&quot;&gt;wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;H. Cohen; H. W. Lenstra&lt;br&gt;&lt;b&gt;Primality Testing and Jacobi Sums&lt;/b&gt;&lt;br&gt;Amsterdam (1984)&lt;br&gt;&lt;a href=&quot;https://www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf&quot;&gt;www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;&lt;a name=5&gt;&lt;/a&gt;Thomas H. Cormen; Charles E. Leiserson; Ronald L. Rivest&lt;br&gt;&lt;b&gt;Introduction to Algorithms&lt;/b&gt;&lt;br&gt;[ без ссылки ]&lt;br&gt;The MIT Press (2001)&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;&lt;a name=6&gt;&lt;/a&gt;M. Martin&lt;br&gt;&lt;b&gt;PRIMO - Primality Proving&lt;/b&gt;&lt;br&gt;&lt;a href=&quot;http://www.ellipsa.net/&quot;&gt;www.ellipsa.net&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;F. Morain&lt;br&gt;&lt;b&gt;Elliptic curves and primality proving&lt;/b&gt;&lt;br&gt;Math. Comp. 61(203) (1993)&lt;br&gt;&lt;a href=&quot;http://citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz&quot;&gt;citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Carl Pomerance&lt;br&gt;&lt;b&gt;Are there counter-examples to the Baillie-PSW primality test?&lt;/b&gt;&lt;br&gt;Math. Comp. (1984)&lt;br&gt;&lt;a href=&quot;http://www.pseudoprime.com/dopo.pdf&quot;&gt;www.pseudoprime.com/dopo.pdf&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Eric W. Weisstein&lt;br&gt;&lt;b&gt;Baillie-PSW primality test&lt;/b&gt;&lt;br&gt;MathWorld (2005)&lt;br&gt;&lt;a href=&quot;http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html&quot;&gt;mathworld.wolfram.com/Baillie-PSWPrimalityTest.html&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Eric W. Weisstein&lt;br&gt;&lt;b&gt;Strong Lucas pseudoprime&lt;/b&gt;&lt;br&gt;MathWorld (2005)&lt;br&gt;&lt;a href=&quot;http://mathworld.wolfram.com/StrongLucasPseudoprime.html&quot;&gt;mathworld.wolfram.com/StrongLucasPseudoprime.html&lt;/a&gt;&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Paulo Ribenboim&lt;br&gt;&lt;b&gt;The Book of Prime Number Records&lt;/b&gt;&lt;br&gt;Springer-Verlag (1989)&lt;br&gt;[ без ссылки ]&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Список других рекомендуемых книг, которых мне не удалось найти в Интернете:&lt;/p&gt;
&lt;ol start=12&gt;
&lt;li&gt;Zhaiyu Mo; James P. Jones&lt;br&gt;&lt;b&gt;A new primality test using Lucas sequences&lt;/b&gt;&lt;br&gt;Preprint (1997)&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;li&gt;Hans Riesel&lt;br&gt;&lt;b&gt;Prime numbers and computer methods for factorization&lt;/b&gt;&lt;br&gt;Boston: Birkhauser (1994)&lt;br&gt;&amp;nbsp;&lt;/li&gt;
&lt;/ol&gt;</textarea></td></tr></table></body></html>