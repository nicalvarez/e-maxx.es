<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Задача 2-SAT (2-CNF)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="/data/jquery.js"></script><script type="text/javascript" src="/data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php" >home</a></li><li><a href="../algo/" class=current>algo</a></li><li><a href="../bookz/" >bookz</a></li><li><a href="../forum/" >forum</a></li><li><a href="../about.php" >about</a></li></ul></td><td class=content><h1>Задача 2-SAT (2-CNF)</h1><p>Page source on the <a href="http://en.wikipedia.org/wiki/HTML">HTML</a> language:</p><textarea style="width:100%;height:500px">&lt;h1&gt;Задача 2-SAT&lt;/h1&gt;
&lt;p&gt;Задача 2-SAT (2-satisfiability) - это задача распределения значений булевым переменным таким образом, чтобы они удовлетворяли всем наложенным ограничениям.&lt;/p&gt;
&lt;p&gt;Задачу 2-SAT можно представить в виде конъюнктивной нормальной формы, где в каждом выражении в скобках стоит ровно по две переменной; такая форма называется 2-CNF (2-conjunctive normal form). Например:&lt;/p&gt;
&lt;formula&gt;(a || c) &amp;&amp; (a || !d) &amp;&amp; (b || !d) &amp;&amp; (b || !e) &amp;&amp; (c || d)&lt;/formula&gt;
&lt;h2&gt;Приложения&lt;/h2&gt;
&lt;p&gt;Алгоритм для решения 2-SAT может быть применим во всех задачах, где есть набор величин, каждая из которых может принимать 2 возможных значения, и есть связи между этими величинами:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Расположение текстовых меток на карте или диаграмме&lt;/b&gt;.&lt;br&gt;Имеется в виду нахождение такого расположения меток, при котором никакие две не пересекаются.&lt;br&gt;Стоит заметить, что в общем случае, когда каждая метка может занимать множество различных позиций, мы получаем задачу general satisfiability, которая является NP-полной. Однако, если ограничиться только двумя возможными позициями, то полученная задача будет задачей 2-SAT.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Расположение рёбер при рисовании графа&lt;/b&gt;.&lt;br&gt;Аналогично предыдущему пункту, если ограничиться только двумя возможными способами провести ребро, то мы придём к 2-SAT.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Составление расписания игр&lt;/b&gt;.&lt;br&gt;Имеется в виду такая система, когда каждая команда должна сыграть с каждой по одному разу, а требуется распределить игры по типу домашняя-выездная, с некоторыми наложенными ограничениями.&lt;/li&gt;
&lt;li&gt;и т.д.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Алгоритм&lt;/h2&gt;
&lt;p&gt;Сначала приведём задачу к другой форме - так называемой импликативной форме. Заметим, что выражение вида a || b эквивалентно !a =&gt; b или !b =&gt; a. Это можно воспринимать следующим образом: если есть выражение a || b, и нам необходимо добиться обращения его в true, то, если a=false, то необходимо b=true, и наоборот, если b=false, то необходимо a=true.&lt;/p&gt;
&lt;p&gt;Построим теперь так называемый &lt;b&gt;граф импликаций&lt;/b&gt;: для каждой переменной в графе будет по две вершины, обозначим их через x&lt;sub&gt;i&lt;/sub&gt; и !x&lt;sub&gt;i&lt;/sub&gt;. Рёбра в графе будут соответствовать импликативным связям.&lt;/p&gt;
&lt;p&gt;Например, для 2-CNF формы:&lt;/p&gt;
&lt;formula&gt;(a || b) &amp;&amp; (b || !c)&lt;/formula&gt;
&lt;p&gt;Граф импликаций будет содержать следующие рёбра (ориентированные):&lt;/p&gt;
&lt;formula&gt;!a =&gt; b
!b =&gt; a
!b =&gt; !c
c =&gt; b&lt;/formula&gt;
&lt;p&gt;Стоит обратить внимание на такое свойство графа импликаций, что если есть ребро a =&gt; b, то есть и ребро !b =&gt; !a.&lt;/p&gt;
&lt;p&gt;Теперь заметим, что если для какой-то переменной x выполняется, что из x достижимо !x, а из !x достижимо x, то задача решения не имеет. Действительно, какое бы значение для переменной x мы бы ни выбрали, мы всегда придём к противоречию - что должно быть выбрано и обратное ему значение. Оказывается, что это условие является не только достаточным, но и необходимым (доказательством этого факта будет описанный ниже алгоритм). Переформулируем данный критерий в терминах теории графов. Напомним, что если из одной вершины достижима другая, а из той вершины достижима первая, то эти две вершины находятся в одной сильно связной компоненте. Тогда мы можем сформулировать &lt;b&gt;критерий существования решения&lt;/b&gt; следующим образом:&lt;/p&gt;
&lt;p&gt;Для того, чтобы данная задача 2-SAT &lt;b&gt;имела решение&lt;/b&gt;, необходимо и достаточно, чтобы для любой переменной x вершины x и !x находились &lt;b&gt;в разных компонентах сильной связности&lt;/b&gt; графа импликаций.&lt;/p&gt;
&lt;p&gt;Этот критерий можно проверить за время O (N + M) с помощью &lt;algohref=strong_connected_components&gt;алгоритма поиска сильно связных компонент&lt;/algohref&gt;.&lt;/p&gt;
&lt;p&gt;Теперь построим собственно &lt;b&gt;алгоритм&lt;/b&gt; нахождения решения задачи 2-SAT в предположении, что решение существует.&lt;/p&gt;
&lt;p&gt;Заметим, что, несмотря на то, что решение существует, для некоторых переменных может выполняться, что из x достижимо !x, или (но не одновременно), из !x достижимо x. В таком случае выбор одного из значений переменной x будет приводить к противоречию, в то время как выбор другого - не будет. Научимся выбирать из двух значений то, которое не приводит к возникновению противоречий. Сразу заметим, что, выбрав какое-либо значение, мы должны запустить из него обход в глубину/ширину и пометить все значения, которые следуют из него, т.е. достижимы в графе импликаций. Соответственно, для уже помеченных вершин никакого выбора между x и !x делать не нужно, для них значение уже выбрано и зафиксировано. Нижеописанное правило применяется только к непомеченным ещё вершинам.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Утверждается&lt;/b&gt; следующее. Пусть comp[v] обозначает номер компоненты сильной связности, которой принадлежит вершина v, причём номера упорядочены в порядке топологической сортировки компонент сильной связности в графе компонентов (т.е. более ранним в порядке топологической сортировки соответствуют большие номера: если есть путь из v в w, то comp[v] &amp;lt;= comp[w]). Тогда, если comp[x] &amp;lt; comp[!x], то выбираем значение !x, иначе, т.е. если comp[x] &gt; comp[!x], то выбираем x.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Докажем&lt;/b&gt;, что при таком выборе значений мы не придём к противоречию. Пусть, для определённости, выбрана вершина x (случай, когда выбрана вершина !x, доказывается симметрично).&lt;/p&gt;
&lt;p&gt;Во-первых, докажем, что из x не достижимо !x. Действительно, так как номер компоненты сильной связности comp[x] больше номера компоненты comp[!x], то это означает, что компонента связности, содержащая x, расположена левее компоненты связности, содержащей !x, и из первой никак не может быть достижима последняя.&lt;/p&gt;
&lt;p&gt;Во-вторых, докажем, что никакая вершина y, достижимая из x, не является &quot;плохой&quot;, т.е. неверно, что из y достижимо !y. Докажем это от противного. Пусть из x достижимо y, а из y достижимо !y. Так как из x достижимо y, то, по свойству графа импликаций, из !y будет достижимо !x. Но, по предположению, из y достижимо !y. Тогда мы получаем, что из x достижимо !x, что противоречит условию, что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Итак, мы построили алгоритм, который находит искомые значения переменных в предположении, что для любой переменной x вершины x и !x находятся в разных компонентах сильной связности. Выше показали корректность этого алгоритма. Следовательно, мы одновременно доказали указанный выше критерий существования решения.&lt;/p&gt;
&lt;p&gt;Теперь мы можем собрать &lt;b&gt;весь алгоритм&lt;/b&gt; воедино:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Построим граф импликаций.&lt;/li&gt;
&lt;li&gt;Найдём в этом графе компоненты сильной связности за время O (N + M), пусть comp[v] - это номер компоненты сильной связности, которой принадлежит вершина v.&lt;/li&gt;
&lt;li&gt;Проверим, что для каждой переменной x вершины x и !x лежат в разных компонентах, т.е. comp[x] &amp;ne; comp[!x]. Если это условие не выполняется, то вернуть &quot;решение не существует&quot;.&lt;/li&gt;
&lt;li&gt;Если comp[x] &gt; comp[!x], то переменной x выбираем значение true, иначе - false.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Реализация&lt;/h2&gt;
&lt;p&gt;Ниже приведена реализация решения задачи 2-SAT для уже построенного графа импликаций g и обратного ему графа gt (т.е. в котором направление каждого ребра изменено на противоположное).&lt;/p&gt;
&lt;p&gt;Программа выводит номера выбранных вершин, либо фразу &quot;NO SOLUTION&quot;, если решения не существует.&lt;/p&gt;
&lt;code&gt;int n;
vector &amp;lt; vector&amp;lt;int&gt; &gt; g, gt;
vector&amp;lt;bool&gt; used;
vector&amp;lt;int&gt; order, comp;

void dfs1 (int v) {
	used[v] = true;
	for (size_t i=0; i&amp;lt;g[v].size(); ++i) {
		int to = g[v][i];
		if (!used[to])
			dfs1 (to);
	}
	order.push_back (v);
}

void dfs2 (int v, int cl) {
	comp[v] = cl;
	for (size_t i=0; i&amp;lt;gt[v].size(); ++i) {
		int to = gt[v][i];
		if (comp[to] == -1)
			dfs2 (to, cl);
	}
}

int main() {
	... чтение n, графа g, построение графа gt ...

	used.assign (n, false);
	for (int i=0; i&amp;lt;n; ++i)
		if (!used[i])
			dfs1 (i);

	comp.assign (n, -1);
	for (int i=0, j=0; i&amp;lt;n; ++i) {
		int v = order[n-i-1];
		if (comp[v] == -1)
			dfs2 (v, j++);
	}

	for (int i=0; i&amp;lt;n; ++i)
		if (comp[i] == comp[i^1]) {
			puts (&quot;NO SOLUTION&quot;);
			return 0;
		}
	for (int i=0; i&amp;lt;n; ++i) {
		int ans = comp[i] &gt; comp[i^1] ? i : i^1;
		printf (&quot;%d &quot;, ans);
	}

}&lt;/code&gt;</textarea></td></tr></table></body></html>