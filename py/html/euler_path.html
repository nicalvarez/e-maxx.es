<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение Эйлерова пути или Эйлерова цикла</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="/data/jquery.js"></script><script type="text/javascript" src="/data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php" >home</a></li><li><a href="../algo/" class=current>algo</a></li><li><a href="../bookz/" >bookz</a></li><li><a href="../forum/" >forum</a></li><li><a href="../about.php" >about</a></li></ul></td><td class=content><h1>Нахождение Эйлерова пути или Эйлерова цикла</h1><p>Page source on the <a href="http://en.wikipedia.org/wiki/HTML">HTML</a> language:</p><textarea style="width:100%;height:500px">&lt;h1&gt;Нахождение Эйлерова пути за O (M)&lt;/h1&gt;

&lt;p&gt;Эйлеров путь - это путь в графе, проходящий через все его рёбра. Эйлеров цикл - это эйлеров путь, являющийся циклом.&lt;/p&gt;
&lt;p&gt;Задача заключается в том, чтобы найти эйлеров путь в &lt;b&gt;неориентированном мультиграфе с петлями&lt;/b&gt;.&lt;/p&gt;
&lt;h2&gt;Алгоритм&lt;/h2&gt;
&lt;p&gt;Сначала проверим, существует ли эйлеров путь. Затем найдём все простые циклы и объединим их в один - это и будет эйлеровым циклом. Если граф таков, что эйлеров путь не является циклом, то, добавим недостающее ребро, найдём эйлеров цикл, потом удалим лишнее ребро.&lt;/p&gt;
&lt;p&gt;Чтобы проверить, существует ли эйлеров путь, нужно воспользоваться следующей теоремой. Эйлеров цикл существует тогда и только тогда, когда степени всех вершин чётны. Эйлеров путь существует тогда и только тогда, когда количество вершин с нечётными степенями равно двум (или нулю, в случае существования эйлерова цикла).&lt;/p&gt;
&lt;p&gt;Кроме того, конечно, граф должен быть достаточно связным (т.е. если удалить из него все изолированные вершины, то должен получиться связный граф).&lt;/p&gt;
&lt;p&gt;Искать все циклы и объединять их будем одной рекурсивной процедурой:&lt;/p&gt;
&lt;pre&gt;procedure FindEulerPath (V)
	1. перебрать все рёбра, выходящие из вершины V;
		каждое такое ребро удаляем из графа, и
		вызываем FindEulerPath из второго конца этого ребра;
	2. добавляем вершину V в ответ.&lt;/pre&gt;
&lt;p&gt;Сложность этого алгоритма, очевидно, является линейной относительно числа рёбер.&lt;/p&gt;
&lt;p&gt;Но этот же алгоритм мы можем записать в &lt;b&gt;нерекурсивном&lt;/b&gt; варианте:&lt;/p&gt;
&lt;pre&gt;stack St;
в St кладём любую вершину (стартовая вершина);
пока St не пустой
	пусть V - значение на вершине St;
	если степень(V) = 0, то
		добавляем V к ответу;
		снимаем V с вершины St;
	иначе
		находим любое ребро, выходящее из V;
		удаляем его из графа;
		второй конец этого ребра кладём в St;
&lt;/pre&gt;
&lt;p&gt;Несложно проверить эквивалентность этих двух форм алгоритма. Однако вторая форма, очевидно, быстрее работает, причём кода будет не больше.&lt;/p&gt;
&lt;h2&gt;Задача о домино&lt;/h2&gt;
&lt;p&gt;Приведём здесь классическую задачу на эйлеров цикл - задачу о домино.&lt;/p&gt;
&lt;p&gt;Имеется N доминошек, как известно, на двух концах доминошки записано по одному числу (обычно от 1 до 6, но в нашем случае не важно). Требуется выложить все доминошки в ряд так, чтобы у любых двух соседних доминошек числа, записанные на их общей стороне, совпадали. Доминошки разрешается переворачивать.&lt;/p&gt;
&lt;p&gt;Переформулируем задачу. Пусть числа, записанные на донимошках, - вершины графа, а доминошки - рёбра этого графа (каждая доминошка с числами (a,b) - это ребра (a,b) и (b,a)). Тогда наша задача &lt;b&gt;сводится к&lt;/b&gt; задаче нахождения &lt;b&gt;эйлерова пути&lt;/b&gt; в этом графе.&lt;/p&gt;
&lt;h2&gt;Реализация&lt;/h2&gt;
&lt;p&gt;Приведенная ниже программа ищет и выводит эйлеров цикл или путь в графе, или выводит -1, если его не существует.&lt;/p&gt;
&lt;p&gt;Сначала программа проверяет степени вершин: если вершин с нечётной степенью нет, то в графе есть эйлеров цикл, если есть 2 вершины с нечётной степенью, то в графе есть только эйлеров путь (эйлерова цикла нет), если же таких вершин больше 2, то в графе нет ни эйлерова цикла, ни эйлерова пути. Чтобы найти эйлеров путь (не цикл), поступим таким образом: если V1 и V2 - это две вершины нечётной степени, то просто добавим ребро (V1,V2), в полученном графе найдём эйлеров цикл (он, очевидно, будет существовать), а затем удалим из ответа &quot;фиктивное&quot; ребро (V1,V2). Эйлеров цикл будем искать в точности так, как описано выше (нерекурсивной версией), и заодно по окончании этого алгоритма проверим, связный был граф или нет (если граф был не связный, то по окончании работы алгоритма в графе останутся некоторые рёбра, и в этом случае нам надо вывести -1). Наконец, программа учитывает, что в графе могут быть изолированные вершины.&lt;/p&gt;
&lt;code&gt;int main() {

	int n;
	vector &amp;lt; vector&amp;lt;int&gt; &gt; g (n, vector&amp;lt;int&gt; (n));
	... чтение графа в матрицу смежности ...

	vector&amp;lt;int&gt; deg (n);
	for (int i=0; i&amp;lt;n; ++i)
		for (int j=0; j&amp;lt;n; ++j)
			deg[i] += g[i][j];

	int first = 0;
	while (!deg[first])  ++first;

	int v1 = -1,  v2 = -1;
	bool bad = false;
	for (int i=0; i&amp;lt;n; ++i)
		if (deg[i] &amp; 1)
			if (v1 == -1)
				v1 = i;
			else if (v2 == -1)
				v2 = i;
			else
				bad = true;

	if (v1 != -1)
		++g[v1][v2],  ++g[v2][v1];

	stack&amp;lt;int&gt; st;
	st.push (first);
	vector&amp;lt;int&gt; res;
	while (!st.empty())
	{
		int v = st.top();
		int i;
		for (i=0; i&amp;lt;n; ++i)
			if (g[v][i])
				break;
		if (i == n)
		{
			res.push_back (v);
			st.pop();
		}
		else
		{
			--g[v][i];
			--g[i][v];
			st.push (i);
		}
	}

	if (v1 != -1)
		for (size_t i=0; i+1&amp;lt;res.size(); ++i)
			if (res[i] == v1 &amp;&amp; res[i+1] == v2 || res[i] == v2 &amp;&amp; res[i+1] == v1)
			{
				vector&amp;lt;int&gt; res2;
				for (size_t j=i+1; j&amp;lt;res.size(); ++j)
					res2.push_back (res[j]);
				for (size_t j=1; j&amp;lt;=i; ++j)
					res2.push_back (res[j]);
				res = res2;
				break;
			}

	for (int i=0; i&amp;lt;n; ++i)
		for (int j=0; j&amp;lt;n; ++j)
			if (g[i][j])
				bad = true;

	if (bad)
		puts (&quot;-1&quot;);
	else
		for (size_t i=0; i&amp;lt;res.size(); ++i)
			printf (&quot;%d &quot;, res[i]+1);

}&lt;/code&gt;</textarea></td></tr></table></body></html>