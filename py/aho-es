\h1{ Algoritmo de Aho-Корасик }
Que dan un conjunto de filas en el alfabeto de tamaño $k$ la longitud combinada de $m$. El algoritmo de Aho-Корасик construye para ello, el conjunto de filas de la estructura de datos de "el bosque" y, a continuación, en este bosque está construyendo una máquina expendedora, todo por $O (m)$ tiempo $O (m k)$ memoria. Recibido expendedora ya se puede utilizar en una variedad de tareas, la más simple de las cuales es encontrar todas las apariciones de cada fila del conjunto en el texto por lineal del tiempo.
\h2{ Boro. La construcción de boro }
Formalmente, \bf{boro} --- es un árbol con raíz en cierta cima de $\rm Root$, y cada arista de un árbol firmado una cierta letra. Si nos fijamos en la lista de aristas que salen de este vértice (además de la costilla, líder del antepasado), todos los bordes deben tener diferentes etiquetas.
Cada vértice de boro también tiene la bandera $\rm leaf$, que es igual a $\rm true$, si en esta parte superior termina en alguna línea del conjunto.
En consecuencia, \bf{construir boro} en este conjunto de filas --- significa construir el boro, que de cada $\rm leaf$-la cima de la coincidirá con alguna cadena de conjunto, y, por el contrario, cada fila del conjunto de coincidirá con algo de $\rm leaf$-la cima.
Introduciremos la estructura correspondiente a las cimas de boro:
\code
struct vertex {
int next[K]
bool leaf
}
vertex t[1 NMAX]
int sz
\endcode
Es decir, vamos a conservar el bosque en forma de matriz $t$ (número de elementos en la matriz es sz) estructuras de $\rm vertex$. La estructura de la $\rm vertex$ contiene el pabellón $\rm leaf$, y de la aleta en forma de matriz $\rm next[]$, donde $\rm next[i]$ --- puntero a la cima, en la que lleva el borde por el símbolo $i$, o $-1$, si las costillas no.
\code
memset (t[0].next, 255, sizeof t[0].next)
sz = 1
\endcode
\code
void add_string (const string 
int v = 0
for (size_t i=0
char c = s[i]-'a'
if (t[v].next[c] == -1) {
memset (t[sz].next, 255, sizeof t[sz].next)
t[v].next[c] = sz 
}
v = t[v].next[c]
}
t[v].leaf = true
}
\endcode
Lineal del tiempo de trabajo, así como lineal, el número de vértices en bora son evidentes. Porque en cada vértice representa $O (k)$ de la memoria, es el uso de memoria es $O (n k)$.
\h2{ la Construcción de la máquina de ranura }
Supongamos que hemos construido boro para el conjunto de filas. Veamos ahora un poco con el otro. Si nos fijamos en cualquier punto, la línea, que coincide con ella, es un prefijo de una o varias filas de un conjunto de
Es decir, podemos entender que la aleta de boro como transiciones en la máquina de la correspondiente a la letra. Sin embargo, solamente las costillas de boro no se puede limitar. Si tratamos de realizar el cambio por cualquier letra, y el costillas en bora no lo es, sin embargo, deben ir a alguna condición.
Por ejemplo, supongamos que el boro construido por filas de $ab$ y $de"bc"$, y estamos bajo el influjo de la cadena $"ab"$ entraron en un estado, que es la hoja de cálculo. Entonces, bajo el influjo de las letras $"c"$ nos vemos obligados a entrar en un estado correspondiente de la barra de $"b"$, y sólo desde allí seguir al pie de la letra $"c"$.
Por lo tanto, hemos reducido la tarea de construir la máquina de ranura a la tarea de encontrar суффиксных de referencia para todos los vértices de boro. Sin embargo, construir estos суффиксные enlaces tendremos, por extraño que parezca, por el contrario, con la ayuda de los construidos en la máquina de navegación.
Por lo tanto, la tarea de encontrar la transición se tradujo a la tarea de encontrar суффиксной enlaces, y la tarea de encontrar суффиксной referencias --- a la tarea de encontrar суффиксной enlaces y la transición, pero ya para los más cercanos a la raíz de los vértices. Hemos recibido una dependencia, pero no infinito, y, además, permitir que se puede por lineal del tiempo.
\code
struct vertex {
int next[K]
bool leaf
int p
char pch
int link
int go[K]
}
vertex t[1 NMAX]
int sz
void init() {
t[0].p = t[0].link = -1
memset (t[0].next, 255, sizeof t[0].next)
memset (t[0].go, 255, sizeof t[0].go)
sz = 1
}
void add_string (const string 
int v = 0
for (size_t i=0
char c = s[i]-'a'
if (t[v].next[c] == -1) {
memset (t[sz].next, 255, sizeof t[sz].next)
memset (t[sz].go, 255, sizeof t[sz].go)
t[sz].link = -1
t[sz].p = v
t[sz].pch = c
t[v].next[c] = sz 
}
v = t[v].next[c]
}
t[v].leaf = true
}
int go (int v, char c)
int get_link (int v) {
if (t[v].link == -1)
if (v == 0 || t[v].p == 0)
t[v].link = 0
t[v].link = go (get_link (t[v].p), t[v].pch)
return t[v].link
}
int go (int v, char c) {
if (t[v].go[c] == -1)
if (t[v].next[c] != -1)
t[v].go[c] = t[v].next[c]
else
t[v].go[c] = v==0 ? 0 : go (get_link (v), c)
return t[v].go[c]
}
\endcode
Es fácil comprender que, gracias a la memorización encontrados суффиксных enlaces y transiciones, el tiempo total de permanencia de todos los суффиксных de vínculos y la navegación es lineal.
\h2{ Aplicación }
\h3{ Buscar todas las filas de un conjunto dado en el texto }
Construiremos en este conjunto de filas de boro. Ahora vamos a tratar el texto de una letra, moviéndose consecuencia de madera, en realidad --- de los estados de la máquina de ranura. Inicialmente estamos en la raíz del árbol. Supongamos que la próxima vez que paso, estamos en un estado $v$, y la letra siguiente texto $c$. Entonces se debe pasar a un estado ${\rm go} (v, c)$, reduciendo o aumentando en $1$ longitud actual de la subcadena coincidente, o reduciendo, pasando por суффиксной enlace.
\h3{ Encontrar лексикографически menor filas de esa longitud, no contiene ninguno de los datos de las muestras }
Dado un conjunto de muestras, y dada la longitud de $L$. Es necesario buscar una cadena de longitud $L$, no contiene ni una de las muestras, y de todas esas cadenas de sacar лексикографически menor.
\h3{ el Hallazgo de la menor anchura de la línea que contiene aparición al mismo tiempo de todas las muestras }
\h3{ Encontrar лексикографически menor de la cadena de longitud $L$, contiene los datos de las muestras en la suma de $k$ más }