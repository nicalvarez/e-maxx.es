\h1{ el teorema Chino de los restos }

\h2{ Redacción }

En su moderna formulación del teorema dice lo siguiente:

Que $p = p_1 \cdot p_2 \cdot \ldots \cdot p_k$, donde $p_i$ --- de dos en dos primos entre sí.

Poner en el cumplimiento de arbitraria entre $a$ $(0 \le a < p)$ tupla $(a_1, \ldots, a_k)$, donde $a_i \equiv a \pmod {p_i}$:

$$ a \Longleftrightarrow (a_1, \ldots, a_k). $$

Entonces es la correspondencia entre los números y tuplas) será \bf{mutuamente clara}. Y, además, las operaciones realizadas en el número de $a$, se puede equivale a realizar sobre los elementos de la tupla --- a través de la independiente de la ejecución de las operaciones sobre cada componente.

Es decir, si

$$ a \Longleftrightarrow \Big( a_1, \ldots, a_k \Big), $$
$ a$ b \Longleftrightarrow \Big( b_1, \ldots, b_k \Big), $$

es cierto:

$$ {(a+b) \pmod p} \Longleftrightarrow \Big( {(a_1+b_1) \pmod {p_1}}, \ldots, {(a_k+b_k) \pmod {p_k}} \Big), $$
$$ {(a-b) \pmod p} \Longleftrightarrow \Big( {(a_1-b_1) \pmod {p_1}}, \ldots, {(a_k-b_k) \pmod {p_k}} \Big), $$
$ $ {a \cdot b) \pmod p} \Longleftrightarrow \Big( {(a_1 \cdot b_1) \pmod {p_1}}, \ldots, {(a_k \cdot b_k) \pmod {p_k}} \Big). $$

En su texto original, este teorema fue demostrado por el matemático chino sun tzu, aproximadamente en el año 100 a.c. es decir, se ha demostrado en el caso particular de la equivalencia de las soluciones de un sistema de модулярных de ecuaciones y solución de un модулярного de la ecuación (véase el resultado 2 a continuación).


\h3{ Resultado 1 }

El sistema de модулярных de ecuaciones:

$$ \cases{
{x \equiv a_1 \pmod {p_1}}, \cr
\ldots, \cr
{x \equiv a_k \pmod {p_k}} \cr
} $$

es la única solución módulo $p$.

(como en el punto anterior, $p = p_1 \cdot \ldots \cdot p_k$, de la cantidad de $p_i$ parejas mutuamente simples, y el conjunto de $a_1, \ldots, a_k$ --- un conjunto aleatorio de números enteros)


\h3{ Resultado 2 }

La consecuencia es la relación entre el sistema модулярных de ecuaciones y una adecuada модулярным dada por la ecuación:

La ecuación:

$$ x \equiv a \pmod p $$

es equivalente al sistema de ecuaciones:

$$ \cases{
{x \equiv a \pmod {p_1}}, \cr
\ldots, \cr
{x \equiv a \pmod {p_k}} \cr
} $$

(como en el punto anterior, se supone que $p = p_1 \cdot \ldots \cdot p_k$, de la cantidad de $p_i$ parejas mutuamente son simples y $a$ --- es un entero arbitrario)


\h2{el Algoritmo de garner}

De china del teorema de los residuos debe, que puede sustituir a las operaciones sobre los números, las operaciones de tuplas. Recordemos, cada número es de $a$ se le asigna una tupla $(a_1, \ldots, a_k)$, donde:

$$ { a_i \equiv a \pmod {p_i} } . $$

Esto puede encontrar una amplia aplicación en la práctica (además de la aplicación directa para la recuperación del número de residuos de diversos módulos), ya que así podemos sustituir la operación en la larga aritmética de las operaciones con la matriz de "cortos" de los números. Diremos que una matriz a partir de $1000$ de los elementos de "suficiente" en un número de alrededor de $3000$ registradas (si selecciona como $p_i$los primeros $1000$ simples); y si se elige como $p_i$s simples alrededor de mil millones, entonces basta ya en número de alrededor de $9000$ registradas. Pero, por supuesto, entonces usted necesita para aprender a \bf{recuperar} número de $a$ de esta tupla. De la investigación 1, se puede ver que esa recuperación es posible, y además el único (siempre $0 \le a < p_1 \cdot p_2 \cdot \ldots \cdot p_k$). \bf{el Algoritmo de garner} y es un algoritmo que permite realizar esta restauración, y es bastante eficaz.

Vamos a buscar una solución en forma de:

$$ a = x_1 + x_2 \cdot p_1 + x_3 \cdot p_1 \cdot p_2 + \ldots + x_k \cdot p_1 \cdot \ldots \cdot p_{k-1}, $$

es decir, en mixto el sistema numérico con pesas decimales $p_1, p_2, \ldots, p_k$.

Se denota por $r_{ij}$ ($i=1, \ldots k-1$, $j=i+1 \ldots k$) número, que es el inverso de a $p_i$ por módulo $p_j$ (búsqueda de inversos de los elementos en el anillo del módulo se describe \algohref=reverse_element{aquí}:

$$ r_{ij} = (p_i) ^ {-1} \pmod {p_j} . $$

Подставим la expresión $a$ mixta el sistema numérico en la primera ecuación del sistema, tenemos:

$$ a_1 \equiv x_1. $$

Подставим ahora de la expresión en la segunda ecuación:

$$ a_2 \equiv x_1 + x_2 \cdot p_1 \pmod {p_2}. $$

Transformar esta expresión, la ruina de ambas partes de $x_1$ y dividiendo en $p_1$:

$$ a_2 - x_1 \equiv x_2 \cdot p_1 \pmod {p_2}; $$
$$ (a_2 - x_1) \cdot r_{12} \equiv x_2 \pmod {p_2}; $$
$$ x_2 \equiv (a_2 - x_1) \cdot r_{12} \pmod {p_2}. $$

Sustituyendo en la tercera ecuación, de manera similar obtenemos:

$$ a_3 \equiv { x_1 + x_2 \cdot p_1 + x_3 \cdot p_1 \cdot p_2 \pmod {p_3} }; $$
$$ (a_3 - x_1) \cdot r_{13} \equiv x_2 + x_3 \cdot p_2 \pmod {p_3}; $$
$$ ((a_3 - x_1) \cdot r_{13} - x_2) \cdot r_{23} \equiv x_3 \pmod {p_3}; $$
$$ x_3 \equiv ((a_3 - x_1) \cdot r_{13} - x_2) \cdot r_{23} \pmod {p_3}. $$

Ya bastante se ve claramente el patrón que es más fácil expresar el código:

\code
for (int i=0; i<k; i++) {
x[i] = a[i];
for (int j=0; j<i; j++) {
x[i] = r[j][i] * x[i] - x[j]);

x[i] = x[i] % p[i];
if (x[i] < 0) x[i] += p[i];
}
}
\endcode

Así, hemos aprendido a calcular los factores de $x_i$ por hora $O (k^2)$, y el mismo la respuesta --- cantidad de $a$ --- se puede recuperar por la fórmula:

$$ a = x_1 + x_2 \cdot p_1 + x_3 \cdot p_1 \cdot p_2 + \ldots + x_k \cdot p_1 \cdot \ldots \cdot p_{k-1}. $$

Vale la pena señalar que, en la práctica, casi siempre calcular la respuesta con la ayuda de \algohref=big_integer{Larga de la aritmética}, pero a los factores de $x_i$ todavía se calculan integrados, de los tipos, sino porque todo el algoritmo de garner, es muy eficaz.


\h2{la Implementación del algoritmo de garner}

El mejor para implementar este algoritmo en el lenguaje Java, ya que contiene el estándar de larga aritmética, y por lo tanto no se produce ningún problema con la traducción de un número de un sistema modular normal de un número predeterminado de la clase BigInteger).

La siguiente implementación del algoritmo garner admite la suma, resta y multiplicación, y apoya el trabajo con los números negativos (sobre esto, consulte la explicación después del código). Se implementa la traducción del número normal de десятичкого presentación en модулярную el sistema y viceversa.

En este ejemplo, se obtienen $100$ simples después de $10^9$, lo que permite trabajar con números hasta aproximadamente $10^{900}$.

\javacode
final int SZ = 100;
int pr[] = new int[SZ];
int r[][] = new int[SZ][SZ];

void init() {
for (int x=1000*1000*1000 i=0; i<SZ; ++x)
if (BigInteger.valueOf(x).isProbablePrime(100))
pr[i++] = x;

for (int i=0; i<SZ; ++i)
for (int j=i+1; j<SZ; ++j)
r[i][j] = BigInteger.valueOf( pr[i] ).modInverse(
BigInteger.valueOf( pr[j] ) ).intValue();
}


class Number {

int a[] = new int[SZ];

public Number() {
}

public Number (int n) {
for (int i=0; i<SZ; ++i)
a[i] = n % pr[i];
}

public Number (BigInteger n) {
for (int i=0; i<SZ; ++i)
a[i] = n.mod( BigInteger.valueOf( pr[i] ) ).intValue();
}

public add Number (Número n) {
Number result = new Number();
for (int i=0; i<SZ; ++i)
result.a[i] = (a[i] + n.a[i]) % pr[i];
return result;
}

public Number subtract (Número n) {
Number result = new Number();
for (int i=0; i<SZ; ++i)
result.a[i] = (a[i] - n.a[i] + pr[i]) % pr[i];
return result;
}

public Number multiply (Número n) {
Number result = new Number();
for (int i=0; i<SZ; ++i)
result.a[i] = (int)( (a[i] * 1n * n.a[i]) % pr[i] );
return result;
}

public BigInteger bigIntegerValue (boolean can_be_negative) {
BigInteger result = BigInteger.ZERO,
mult = BigInteger.ONE;
int x[] = new int[SZ];
for (int i=0; i<SZ; ++i) {
x[i] = a[i];
for (int j=0; j<i; j++) {
long cur = (x[i] - x[j]) * 1n * r[j][i];
x[i] = (int)( (cur % pr[i] + pr[i]) % pr[i] ); 
}
result = result.add( mult.multiply( BigInteger.valueOf( x[i] ) ) );
mult = mult.multiply( BigInteger.valueOf( pr[i] ) );
}

if (can_be_negative)
if (result.compareTo( mult.shiftRight(1) ) >= 0)
result = result.subtract( mult );

return result;
}
}
\endcode

Sobre el apoyo de \bf{negativos} de números cabe destacar (la bandera $\rm can\_be\_negative$ función ${\rm bigIntegerValue}()$). Sí: modular, el esquema no implica diferencias entre positivos y negativos. Sin embargo, se puede observar que, si en una tarea específica de respuesta de módulo no supera la mitad de la obra de todos los simples, los números positivos serán diferentes de los negativos, el hecho de que los números positivos se verán menos de este medio, mientras que los negativos --- más. Por lo tanto, estamos después del clásico algoritmo de garner comparamos el resultado con el medio, y si es mayor, lo sacamos menos, y de invertir el resultado (es decir, llevamos de obras de todos los simples, y llegamos ya de él).
