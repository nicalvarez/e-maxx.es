<h1>the Task of covering segments by points</h1>
<p>you are Given N segments on a straight line. You want to coat them with the least number of points, i.e. to find the smallest set of points such that each segment belongs to at least one point.</p>
<p>Also consider a more complicated variant of this problem is when additionally stated "prohibited" a set of line segments, i.e. no point of the answer should not belong to any segment is prohibited.</p>
<p>it Should also be noted that this task can be considered as a task in the scheduling is required to cover a specified set of activities of segments of the least number of points.</p>
<p>Below will be described a greedy algorithm that solves both tasks at <b>O (N log N)</b>.</p>
the <h2>first task</h2>
<p>first, observe that we can consider only those solutions in which each point is located on the right end of any segment. Indeed, it is easy to see that any solution, if it satisfies this property, it is possible to lead people to him, shifting his point to the right as much as possible.</p>
<p>let us now build a solution that satisfies the specified property. Take points, the right ends of segments, sort them, and we'll move through them from left to right. If the current point is the right end of the segment is already covered, then we are missing it. Now suppose the current point is the right end of the segment, which has not been covered before. Then we must add in response to the current point, and mark all the segments which belong to this point as covered. Indeed, if we missed the current point and would not add it to the answer, because it is the right end of the segment, we have not been able to cover the current segment.</p>
<p>However, a naive implementation of this method will work in O (N<sup>2</sup>). Describe <b>efficient implementation</b> method.</p>
<p>Take all the points-the endpoints of the segments (both left and right) and sort them. For each point keep along with it the number of the segment, as well as how late it is (left or right). In addition, let's sort the points so that if there are multiple points with one coordinate, then the first will go left and then right. Please start the stack in which are stored the numbers of the line segments under consideration at the moment; initially the stack is empty. We will move by the points in sorted order. If the current point is the left end, then just add the number of the line segment in the stack. If it is the right end, we check whether this segment is covered (you can just make an array of Booleans). If it was already covered, then do nothing and move on to the next point (going forward, we argue that in this case, the current stack segment is not). If it is not covered yet, we add the current point in the answer, and now we want to note for all current segments that they be covered. Because the stack just stores the number of still uncovered segment, we are going to get from the stack to one segment and to note that it is already covered until the stack is completely empty. At the end of the algorithm all segments are covered, and, moreover, the least number of points (again, here is important, that in case of equality of first coordinates of the left ends and then right).</p>
<p>Thus, the whole algorithm runs in O (N), not counting the sorting outlets, and the overall complexity of the algorithm is just equal to the <b>O (N log N)</b>.</p>
the <h2>the second problem</h2>
<p>There are emerging segments is forbidden, therefore, first, the solutions do not exist, and secondly, it cannot be argued that the answer can be only from the right endpoints of the segments. However, the algorithm described above can be suitably modified.</p>
<p>Again take all the points-the endpoints of the segments (target segments, and prohibited), sort them, keeping each point of its type and period, the end of which it is. Again, sort the segments so that when the equality of the coordinates of the left ends were right before, and if all types are equal, the left ends are prohibited should go before the left ends the task and right ends prohibited - after target (to prohibited the segments was taken into account as long as possible in case of equality of coordinates). Please start the counter of forbidden segments, which will be equal to the number of segments is prohibited, covering the current point. Please start the queue (queue) in which to store the number of current target segments. Iterate over the points in sorted order. If the current point is the left end of the target segment, just add the number of her cut in line. If the current point is the right end of the target segment, then, if the counter forbidden lines are equal to zero, then we proceed similarly to the previous task - set point to the current point, and pushes all the segments from the queue, noting that they are covered. If the counter is prohibited segment is greater than zero, then the current point we are not able to shoot, but because we need to find the most recent point-free segments is prohibited; it is necessary to accommodate the last_free pointer that will be updated upon receipt of prohibited intervals. Then we shoot at last_free-EPS (because it can not directly shoot - this point belongs to the segment is prohibited), and to push the segments from the queue until the point last_free-EPS belongs to them. Namely, if the current point is the left end of the cut is prohibited, then we increase a counter and if the counter was equal to zero, assign to current last_free coordinate. If the current point is the right end of the cut is forbidden, we just decrement the counter.</p>