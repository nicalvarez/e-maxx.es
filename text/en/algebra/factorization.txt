<h1>Effective algorithms for factorization</h1>
<hr>
<p>Here is the implementation of several algorithms factorization, each of which individually can work as quickly or very slowly, but together they give a very quick method.</p>
<p>Descriptions of these methods are not given, the more that they are quite well described on the Internet.</p>
<h2>Method Pollard's p-1</h2>
<p>a Probabilistic test that quickly gives the answer is not all numbers.</p>
the <code>template 
T pollard_p_1 (T n)
{
// algorithm parameters significantly affect the performance and the quality of search
const T b = 13
const T q[] = { 2, 3, 5, 7, 11, 13 }
// several attempts algorithm
T a = 5 % n
for (int j=0
{
// search for such a which are mutually simply n
while (gcd (a, n) != 1)
{
mulmod (a, a, n)
a = 3
a %= n
}
// computed a^M
for (size_t i = 0
{
T qq = q[i]
T e = (T) floor (log ((double)b) / log ((double)qq))
T aa = powmod (a, powmod (qq, e, n), n)
if (aa == 0)
continue
T g = gcd (aa-1, n)
if (1 
return g
}
}
// if nothing found
return 1
}</code>
<h2>Method of Pollard "Rho"</h2>
<p>a Probabilistic test that quickly gives the answer is not all numbers.</p>
<p>Returns either found divider, or 1 if the divisor was not found.</p>
the <code>template 
T pollard_rho (T n, unsigned iterations_count = 100000)
{
T
b0 = rand() % n,
b1 = b0,
g
mulmod (b1, b1, n)
if ( b1 == n)
b1 = 0
g = gcd (abs (b1 - b0), n)
for (unsigned count=0
{
mulmod (b0, b0, n)
if ( b0 == n)
mulmod (b1, b1, n)
 b1
mulmod (b1, b1, n)
if ( b1 == n)
b1 = 0
g = gcd (abs (b1 - b0), n)
}
return g
}</code>
<h2>Method is bent (modification of the method of Pollard "Rho")</h2>
<p>a Probabilistic test that quickly gives the answer is not all numbers.</p>
<p>Returns either found divider, or 1 if the divisor was not found.</p>
the <code>template 
T pollard_bent (T n, unsigned iterations_count = 19)
{
T
b0 = rand() % n,
b1 = (b0*b0 2) % n,
a = b1
for (unsigned iteration=0, series_len=1
{
T g = gcd (b1-b0, n)
{
b1 = (b1*b1 2) % n
g = gcd (abs(b1-b0), n)
}
b0 = a
a = b1
if (g != 1 
return g
}
return 1
}</code>
<h2>Method of Pollard Monte Carlo</h2>
<p>a Probabilistic test that quickly gives the answer is not all numbers.</p>
<p>Returns either found divider, or 1 if the divisor was not found.</p>
the <code>template 
T pollard_monte_carlo (T n, unsigned m = 100)
{
T b = rand() % (m-2) 2
static std::vector
static T m_max
if (primes.empty())
primes.push_back (3)
if (m_max < m)
{
m_max = m
for (T prime=5
{
bool is_prime = true
iter!=end
{
T div = *iter
if (div*div > prime)
break
if (prime % div == 0)
{
is_prime = false
break
}
}
if (is_prime)
primes.push_back (prime)
}
}
T g = 1
for (size_t i=0
{
T cur = primes[i]
while (cur 
cur *= primes[i]
cur /= primes[i]
b = powmod (b, cur, n)
g = gcd (abs(b-1), n)
if (g == n)
g = 1
}
return g
}</code>
<h2>Method Farm</h2>
<p>This absolute method, but it can be very slow if the number is small divisors.</p>
the <code>template 
T ferma (const T 
{
T2
x = sq_root (n),
y = 0,
r = x*x - y*y - n
for (
if (r == 0)
return x!=y ? x-y : x y
else
if (r > 0)
{
r -= y y 1
 y
}
else
{
r = x x 1
 x
}
}</code>
<h2>Trivial division</h2>
<p>This simple method will be useful to handle numbers with very small divisors.</p>
the <code>template 
T2 prime_div_trivial (const T 
{
// first check in trivial cases
if (n == 2 || n == 3)
return 1
if (n < 2)
return 0
if (even (n))
// generated by easy 3 to m
T2 pi
const vector
// divide all simple
for (std::vector
iter!=end
{
const T2 
if (div * div > n)
break
else
if (n % div == 0)
return div
}
if (n < m*m)
return 1
return 0
}</code>
<h2>putting it all together</h2>
<p>Combine all the methods in one function.</p>
the <code>template 
void factorize (const T 
{
if (n == 1)

else
// check whether the number of simple
if (isprime (n))
 result[n]
else
// if the number is sufficiently small, it is degradable by a simple enumeration
if (n < 1000*1000)
{
T div = prime_div_trivial (n, 1000)
 result[div]
factorize (n / a div, result, unused)
}
else
{
// number of big run on it the factorization algorithms
T div
// first, go fast algorithms of Pollard
div = pollard_monte_carlo (n)
if (div == 1)
div = pollard_rho (n)