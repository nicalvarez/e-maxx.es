\<h1>Максимальный поток методом Эдмондса-Карпа за O (N M<sup>2</sup>)</h1>

<p style="color:red">Внимание: данная статья устарела и содержит ошибки и не рекомендуется к чтению. Через некоторое время статья будет полностью переписана.</p>

<p>Пусть дан граф G, в котором выделены две вершины: исток S и сток T, а у каждого ребра определена пропускная способность C<sub>u,v</sub>. Поток F можно представить как поток вещества, которое могло бы пройти по сети от истока к стоку, если рассматривать граф как сеть труб с некоторыми пропускными способностями. Т.е. поток - функция F<sub>u, v</sub>, определённая на множестве рёбер графа.</p>
<p>&nbsp;</p>
<p>Задача заключается в нахождении максимального потока. Здесь будет рассмотрен метод Эдмондса-Карпа, работающий за O (N M<sup>2</sup>), или (другая оценка) O (F M), где F - величина искомого потока. Алгоритм был предложен в 1972 году.</p>
<h2>Алгоритм</h2>
<p><b>Остаточной пропускной способностью</b> называется пропускная способность ребра за вычетом текущего потока вдоль этого ребра. При этом надо помнить, что если некоторый поток протекает по ориентированному ребру, то возникает так называемое обратное ребро (направленное в обратную сторону), которое будет иметь нулевую пропускную способность, и по которому будет протекать тот же по величине поток, но со знаком минус. Если же ребро было неориентированным, то оно как бы распадается на два ориентированных ребра с одинаковой пропускной способностью, и каждое из этих рёбер является обратным для другого (если по одному протекает поток F, то по другому протекает -F).</p>
<p>Общая схема <b>алгоритма Эдмондса-Карпа</b> такова. Сначала полагаем поток равным нулю. Затем ищем дополняющий путь, т.е. простой путь из S в T по тем рёбрам, у которых остаточная пропускная способность строго положительна. Если дополняющий путь был найден, то производится увеличение текущего потока вдоль этого пути. Если же пути не было найдено, то текущий поток является максимальным. Для поиска дополняющего пути может использоваться как <algohref=bfs>Обход в ширину</algohref>, так и <algohref=dfs>Обход в глубину</algohref>.</p>
<p>Рассмотрим более точно процедуру увеличения потока. Пусть мы нашли некоторый дополняющий путь, тогда пусть C - наименьшая из остаточных пропускных способностей рёбер этого пути. Процедура увеличения потока заключается в следующем: для каждого ребра (u, v) дополняющего пути выполним: F<sub>u, v</sub> += C, а F<sub>v, u</sub> = - F<sub>u, v</sub> (или, что то же самое, F<sub>v, u</sub> -= C).</p>
<p>Величиной потока будет сумма всех неотрицательных величин F<sub>S, v</sub>, где v - любая вершина, соединённая с истоком.</p>
<h2>Реализация</h2>
<code>const int inf = 1000*1000*1000;


typedef vector&lt;int> graf_line;
typedef vector&lt;graf_line> graf;

typedef vector&lt;int> vint;
typedef vector&lt;vint> vvint;


int main()
{
	int n;
	cin >> n;
	vvint c (n, vint(n));
	for (int i=0; i&lt;n; i++)
		for (int j=0; j&lt;n; j++)
			cin >> c[i][j];
	// исток - вершина 0, сток - вершина n-1

	vvint f (n, vint(n));
	for (;;)
	{
		
		vint from (n, -1);
		vint q (n);
		int h=0, t=0;
		q[t++] = 0;
		from[0] = 0;
		for (int cur; h&lt;t;)
		{
			cur = q[h++];
			for (int v=0; v&lt;n; v++)
				if (from[v] == -1 &&
					c[cur][v]-f[cur][v] > 0)
				{
					q[t++] = v;
					from[v] = cur;
				}
		}

		if (from[n-1] == -1)
			break;
		int cf = inf;
		for (int cur=n-1; cur!=0; )
		{
			int prev = from[cur];
			cf = min (cf, c[prev][cur]-f[prev][cur]);
			cur = prev;
		}

		for (int cur=n-1; cur!=0; )
		{
			int prev = from[cur];
			f[prev][cur] += cf;
			f[cur][prev] -= cf;
			cur = prev;
		}

	}

	int flow = 0;
	for (int i=0; i&lt;n; i++)
		if (c[0][i])
			flow += f[0][i];

	cout &lt;&lt; flow;

}</code>h1{Наименьший общий предок. Нахождение за $O(1)$ в оффлайн (алгоритм Тарьяна)}

Дано дерево $G$ с $n$ вершинами и дано $m$ запросов вида $(a_i, b_i)$. Для каждого запроса $(a_i, b_i)$ требуется найти наименьшего общего предка вершин $a_i$ и $b_i$, т.е. такую вершину $c_i$, которая наиболее удалена от корня дерева, и при этом является предком обеих вершин $a_i$ и $b_i$.

Мы рассматриваем задачу в режиме оффлайн, т.е. считая, что все запросы известны заранее. Описываемый ниже алгоритм позволяет ответить на все $m$ запросов за суммарное время $O(n+m)$, т.е. при достаточно большом $m$ за $O(1)$ на запрос.

\h2{Алгоритм Тарьяна}

Основой для алгоритма является структура данных \algohref=dsu{"Система непересекающихся множеств"}, которая и была изобретена Тарьяном (Tarjan).

Алгоритм фактически представляет собой обход в глубину из корня дерева, в процессе которого постепенно находятся ответы на запросы. А именно, ответ на запрос $(v,u)$ находится, когда обход в глубину находится в вершине $u$, а вершина $v$ уже была посещена, или наоборот.

Итак, пусть обход в глубину находится в вершине $v$ (и уже были выполнены переходы в её сыновей), и оказалось, что для какого-то запроса $(v,u)$ вершина $u$ уже была посещена обходом в глубину. Научимся тогда находить $\rm LCA$ этих двух вершин.

Заметим, что ${\rm LCA}(v,u)$ является либо самой вершиной $v$, либо одним из её предков. Получается, нам надо найти самую нижнюю вершину среди предков $v$ (включая её саму), для которой вершина $u$ является потомком. Заметим, что при фиксированном $v$ по такому признаку (т.е. какой наименьший предок $v$ является и предком какой-то вершины) вершины дерева дерева распадаются на совокупность непересекающихся классов. Для каждого предка $p \not= v$ вершины $v$ её класс содержит саму эту вершину, а также все поддеревья с корнями в тех её сыновьях, которые лежат "слева" от пути до $v$ (т.е. которые были обработаны ранее, чем была достигнута $v$).

Нам надо научиться эффективно поддерживать все эти классы, для чего мы и применим структуру данных "Система непересекающихся множеств". Каждому классу будет соответствовать в этой структуре множество, причём для представителя этого множества мы определим величину $\rm ANCESTOR$ --- ту вершину $p$, которая и образует этот класс.

Рассмотрим подробно реализацию обхода в глубину. Пусть мы стоим в некоторой вершине $v$. Поместим её в отдельный класс в структуре непересекающихся множеств, ${\rm ANCESTOR}[v] = v$. Как обычно в обходе в глубину, перебираем все исходящие рёбра $(v, to)$. Для каждого такого $to$ мы сначала должны вызвать обход в глубину из этой вершины, а потом добавить эту вершину со всем её поддеревом в класс вершины $v$. Это реализуется операцией $\rm Union$ структуры данных "система непересекающихся множеств", с последующей установкой ${\rm ANCESTOR} = v$ для представителя множества (т.к. после объединения представитель класса мог измениться). Наконец, после обработки всех рёбер мы перебираем все запросы вида $(v,u)$, и если $u$ была помечена как посещённая обходом в глубину, то ответом на этот запрос будет вершина ${\rm LCA}(v,u) = {\rm ANCESTOR}[{\rm FindSet}(u)]$. Нетрудно заметить, что для каждого запроса это условие (что одна вершина запроса является текущей, а другая была посещена ранее) выполнится ровно один раз.

Оценим \bf{асимптотику}. Она складывается из нескольких частей. Во-первых, это асимптотика обхода в глубину, которая в данном случае составляет $O(n)$. Во-вторых, это операции по объединению множеств, которые в сумме для всех разумных $n$ затрачивают $O(n)$ операций. В-третьих, это для каждого запроса проверка условия (два раза на запрос) и определение результата (один раз на запрос), каждое, опять же, для всех разумных $n$ выполняется за $O(1)$. Итоговая асимптотика получается $O(n+m)$, что означает для достаточно больших $m$ ($n = O(m)$) ответ за $O(1)$ на один запрос.

\h2{Реализация}

Приведём полную реализацию данного алгоритма, включая слегка изменённую (с поддержкой $\rm ANCESTOR$) реализацию системы пересекающихся множеств (рандомизированный варианта).

\code
const int MAXN = максимальное число вершин в графе;
vector<int> g[MAXN], q[MAXN]; // граф и все запросы
int dsu[MAXN], ancestor[MAXN];
bool u[MAXN];

int dsu_get (int v) {
	return v == dsu[v] ? v : dsu[v] = dsu_get (dsu[v]);
}

void dsu_unite (int a, int b, int new_ancestor) {
	a = dsu_get (a),  b = dsu_get (b);
	if (rand() & 1)  swap (a, b);
	dsu[a] = b,  ancestor[b] = new_ancestor;
}

void dfs (int v) {
	dsu[v] = v,  ancestor[v] = v;
	u[v] = true;
	for (size_t i=0; i<g[v].size(); ++i)
		if (!u[g[v][i]]) {
			dfs (g[v][i]);
			dsu_unite (v, g[v][i], v);
		}
	for (size_t i=0; i<q[v].size(); ++i)
		if (u[q[v][i]]) {
			printf ("%d %d -> %d\n", v+1, q[v][i]+1,
				ancestor[ dsu_get(q[v][i]) ]+1);
}

int main() {
	... чтение графа ...

	// чтение запросов
	for (;;) {
		int a, b = ...; // очередной запрос
		--a, --b;
		q[a].push_back (b);
		q[b].push_back (a);
	}

	// обход в глубину и ответ на запросы
	dfs (0);
}
\endcode
